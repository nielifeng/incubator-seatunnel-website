<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.16">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Apache SeaTunnel RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Apache SeaTunnel Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/user_cases/rss.xml" title="Apache SeaTunnel RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/user_cases/atom.xml" title="Apache SeaTunnel Atom Feed">
<script src="https://hm.baidu.com/hm.js?33a9aab233e1082f91e4e347ad716701" async></script><title data-rh="true">Blog | Apache SeaTunnel</title><meta data-rh="true" property="og:title" content="Blog | Apache SeaTunnel"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" property="og:url" content="https://seatunnel.apache.org/blog"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/image/favicon.ico"><link data-rh="true" rel="canonical" href="https://seatunnel.apache.org/blog"><link data-rh="true" rel="alternate" href="https://seatunnel.apache.org/blog" hreflang="en"><link data-rh="true" rel="alternate" href="https://seatunnel.apache.org/zh-CN/blog" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://seatunnel.apache.org/blog" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.41b6544e.css">
<link rel="preload" href="/assets/js/runtime~main.8e37f3a6.js" as="script">
<link rel="preload" href="/assets/js/main.80d5c78f.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><div class="announcementBar_IbjG" style="background-color:rgb(70, 125, 175, 0.8)" role="banner"><div class="announcementBarContent_KsVm">🤔 Have queries regarding Apache SeaTunnel, Join Slack channel to discuss them join <a target="_blank" rel="noopener noreferrer" href="https://join.slack.com/t/apacheseatunnel/shared_invite/zt-123jmewxe-RjB_DW3M3gV~xL91pZ0oVQ">#SeaTunnel</a> channel! 🌟</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/image/logo.png" alt="Apache SeaTunnel Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/image/logo.png" alt="Apache SeaTunnel Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Apache SeaTunnel</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/">Home</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link">Document</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/2.3.0/about">2.3.0</a></li><li><a class="dropdown__link" href="/docs/2.3.0-beta/about">2.3.0-beta</a></li><li><a class="dropdown__link" href="/docs/2.2.0-beta/intro/about">2.2.0-beta</a></li><li><a class="dropdown__link" href="/docs/2.1.3/intro/about">2.1.3</a></li><li><a class="dropdown__link" href="/docs/2.1.2/intro/about">2.1.2</a></li><li><a class="dropdown__link" href="/docs/2.1.1/intro/about">2.1.1</a></li><li><a class="dropdown__link" href="/docs/2.1.0/introduction">2.1.0</a></li><li><a class="dropdown__link" href="/docs/1.x/introduction">1.x(Not Apache Release)</a></li><li><a class="dropdown__link" href="/docs/about">Next</a></li><li><a class="dropdown__link" href="/versions/">All versions</a></li></ul></div><a class="navbar__item navbar__link" href="/download">Download</a><a class="navbar__item navbar__link" href="/community/contribution_guide/contribute">Community</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/user_cases">UserCases</a><a class="navbar__item navbar__link" href="/team">Team</a><a class="navbar__item navbar__link" href="/user">Users</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/current-event" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://www.apache.org/security/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li></ul></div><a href="https://github.com/apache/incubator-seatunnel" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/Apache IoTDB (Internet of Things Database) is a software system that integrates the collection">SeaTunnel supports IoTDB to implement IoT data synchronization</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/Apache SeaTunnel Committer | Zongwen Li">SeaTunnel engine, designed for tens-of-billions data integration</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/During the joint Apache SeaTunnel &amp; IoTDB Meetup on October 15,">Mafengwo finally chose Apache SeaTunnel after analyzing these 9 points of how it works!</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/09/20/A-tutorial-to-help-you develop-a-SeaTunnel-Connector-hand-by-hand-while-avoiding -pitfalls">A tutorial to help you develop a SeaTunnel Connector hand-by-hand while avoiding pitfalls</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/09/19/Code-Demo-for-SeaTunnel-Connector-Development-Process">Code Demo for SeaTunnel Connector Development Process</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/Apache IoTDB (Internet of Things Database) is a software system that integrates the collection">SeaTunnel supports IoTDB to implement IoT data synchronization</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-12-10T00:00:00.000Z" itemprop="datePublished">December 10, 2022</time> · <!-- -->12 min read</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/assets/images/16714316482580-41ece0a1c0d976185e2c75f3329aa12d.jpg" width="720" height="320"></p><blockquote><p>Apache IoTDB (Internet of Things Database) is a software system that integrates the collection, storage, management, and analysis of time series data of the Internet of Things, which can meet the needs of massive data storage, high-speed data reading, and complex data analysis in the field of Industrial Internet of Things. Currently, SeaTunnel already supports IoTDB Connector, realizing the connection of data synchronization scenarios in the IoT field.</p></blockquote><blockquote><p>At the SeaTunnel community online meeting in October this year, SeaTunnel Committer Wang Hailin introduced the implementation process of SeaTunnel’s access to IoTDB, allowing users to have a deeper understanding of the operation method and principle of IoTDB data synchronization.</p></blockquote><p>The topic I’m sharing today is using SeaTunnel to play around with data synchronization in IoTDB.</p><p>This session is divided into 6 subsections. Firstly, we will have an understanding of the basic concept of SeaTunnel, and on this basis, we will focus on the functional features of IoTDB Connector, then we will analyze the data read and write functions of IoTDB Connector and the parsing of the implementation, and finally, we will show some typical usage scenarios and cases to let you understand how to use Finally, we will show some typical usage scenarios and cases to understand how to use the IoTDB Connector to implement into production environments. The last point is the community’s next steps for the IoTDB Connector and guidance on how to get involved in contributing.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="introduction-to-seatunnel-basic-concepts">Introduction to SeaTunnel basic concepts<a class="hash-link" href="#introduction-to-seatunnel-basic-concepts" title="Direct link to heading">​</a></h2><p>This is the basic architecture of SeaTunnel, an engine built for data synchronization, with a set of abstract APIs for reading data from and writing to a variety of data sources.</p><p><img loading="lazy" src="/assets/images/16714316839299-a92e73bfbc3881b099146d6d161c412f.jpg" width="720" height="389">
The left-hand side briefly lists the Source scenarios, for example, we abstract the Source’s API, Type, and State, to read the data source, unifying the data types of the various data sources to the abstract type defined in it, and some state recovery and retention of the read location during the reading process.</p><p>This is an abstraction for Source, and we have done a similar abstraction for Sink, i.e. how data is written, and how the data type matches the real data source type, and how the state is restored and retained.</p><p>Based on these APIs, we will have a translation layer to translate these APIs to the corresponding execution engine. SeaTunnel currently supports three execution engines, Spark, Flink, and our own execution engine, SeaTunnel Engine, which will be released soon.</p><p>This is roughly what SeaTunnel does, SeaTunnel relies on Source and Sink to read and write data for data synchronization, we call them Connectors. The Connector consists of a Source and a Sink.</p><p><img loading="lazy" src="/assets/images/16714316928812-337c3d4770094c09ae55a5312670d87f.jpg" width="720" height="758">
From the diagram above we see the different data sources, Source is responsible for reading data from the various data sources and transforming it into SeaTunnelRow abstraction layer and Type to form the abstraction layer, Sink is responsible for pulling data from the abstraction layer and writing it to the concrete data store to transform it into the store concrete format.</p><p>The combination of Source + Abstraction Layer + Sink enables the synchronization of data between multiple heterogeneous data sources.</p><p>I’ll use a simple example below to illustrate how SeaTunnel’s Source and Sink work.</p><p><img loading="lazy" src="/assets/images/16714317022389-f17930bc8877d173d40eab8fdfe47631.jpg" width="720" height="822"></p><p><img loading="lazy" src="/assets/images/16714317067444-f828b5a72003d3caec8958edccdc8dca.jpg" width="720" height="340">
We can specify the number of Sources, Sink configuration file combinations through the configuration file The commands in the toolkit provided by SeaTunnel take the configuration file with them and when executed enable data handling.</p><p><img loading="lazy" src="/assets/images/16714317166018-4c6a20778066aa8bfb5c319c4706b17b.jpg" width="720" height="1202">
<img loading="lazy" src="/assets/images/16714317203806-c4d2fe2e0a1d9a235d59e878c42b9308.jpg" width="651" height="1280">
<img loading="lazy" src="/assets/images/16714317262218-a608b27e7ed69d6bab301f6bdf929966.jpg" width="720" height="933">
This is the Connector ecosystem that is currently supported by SeaTunnel, such as the data sources supported by JBDC, HDFS, Hive, Pulsar, message queues, etc. are currently supported.</p><p>The list in the picture is not exhaustive of the Connectors supported by SeaTunnel. Under the GitHub SeaTunnel project, you can see the Plugins directory, where supported Connector plugins are constantly being added and where you can see the latest access in real-time.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="iotdb-connector-features">IoTDB Connector Features<a class="hash-link" href="#iotdb-connector-features" title="Direct link to heading">​</a></h2><p>Below is information about access to the IoTDB Connector.</p><p>Firstly, we would like to introduce the functional features of IoTDB, the IoTDB Connector integrated with SeaTunnel, and what exactly it supports for your reference.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="source-features">Source Features<a class="hash-link" href="#source-features" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714317512435-d9aa02e6d36efefd2a2c20cf77ce8f6b.jpg" width="720" height="384">
Firstly, there are the typical usage scenarios supported by Source, such as bulk reading of devices, field projection, data type mapping, parallel reading, etc.</p><p>As you can see above, IoTDB supports all features except once, exactly once and stream mode, such as batch reads, IoTDB has a SQL syntax similar to group by device, which allows you to read data from multiple devices in a single batch. For basic data type projection, the SQL in IoTDB will take time by default when looking up any metric, or group by the device will take the device column, and we also support projection onto SeaTunnel columns by default.</p><p>The only data type not supported is Victor, all others are supported.</p><p>For the parallel read piece, the IoTDB data is actually timestamped and we use timestamped ranges to achieve parallel reads.</p><p>The recovery of the state, since we have divided the time range read into different splits, can be done based on the Split location information.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="sink-functional-features">Sink functional features<a class="hash-link" href="#sink-functional-features" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714317679569-a1923e70d93e6204c42aa7531a96a024.jpg" width="720" height="372"></p><p>The diagram above shows the features already supported by SeaTunnel. Regarding metadata extraction, we support the extraction of metadata such as measurement, device, etc. from SeaTunnelRow and the extraction or use of current processing time from SeaTunnelRow. Batch commits and exception retries are also supported.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="iotdb-data-reading-analysis">IoTDB data reading analysis<a class="hash-link" href="#iotdb-data-reading-analysis" title="Direct link to heading">​</a></h2><p>Next, we analyze the implementation and support for data reading.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="data-type-mapping">Data type mapping<a class="hash-link" href="#data-type-mapping" title="Direct link to heading">​</a></h2><p>The first is the data type mapping, which actually reads the IoTDB data type to SeaTunnel, so it has to be converted to the SeaTunnel data type.
<img loading="lazy" src="/assets/images/16714317930593-3931931989e2fc8224bb071304463c53.jpg" width="720" height="460">
The BOOLEAN, INT32, INT64, etc. listed here all have corresponding SeaTunnel data types. INT32 can be mapped according to the read type on the SeaTunnel, or to TINYINT, SMALLINT, or INT when the range of values is small.</p><p>The Vector type is not currently supported.</p><p><img loading="lazy" src="/assets/images/16714318216373-6472b0b9745b67620ca357054a0715fb.jpg" width="720" height="758">
This is the corresponding example code showing how the mapping is done where the type conversion is done.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="field-projection">Field projection<a class="hash-link" href="#field-projection" title="Direct link to heading">​</a></h2><p>The other is the field projection when reading, we can automatically map Time fields when reading IoTDB data, or we can choose to map some of the data to SeaTunnel, such as TIMESTAMP, or BIGINT.</p><p><img loading="lazy" src="/assets/images/16714318381313-29a760765ae69e80e04015976521aabe.jpg" width="720" height="320">
The SQL extraction of column codes allows you to extract only some of the columns you need, and when used on SeaTunnel, you can specify the name, type, etc. of the column after it is mapped to SeaTunnel via fields. The final result of the data read on SeaTunnel is shown in the figure above.</p><p><img loading="lazy" src="/assets/images/16714318550071-25f4bde1d47b33463a1f2d6e13651435.jpg" width="720" height="368"></p><p>We have just seen that we do not have the time column in the SQL, but the actual result is that there is this column, so we support the projection of the time column field, the time column can actually be projected into different data types, the user can convert according to their needs. The diagram above shows the implementation logic.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="batch-read-device">Batch read Device<a class="hash-link" href="#batch-read-device" title="Direct link to heading">​</a></h2><p>This is a common requirement, as we are likely to synchronize data in large batches with the same data structure.</p><p><img loading="lazy" src="/assets/images/16714318796196-bee32b3eae066fdc0ce82182fc6eeb09.jpg" width="720" height="333"></p><p>SeaTunnel supports the align-by-device syntax so that device columns can also be projected onto the SeaTunnelRow</p><p><img loading="lazy" src="/assets/images/16714318873362-54b8d7281a93bc335a39e995db5e1a4f.jpg" width="720" height="185">
Assuming there is a table in IoTDB, we project the device column onto SeaTunnel by making it data as well through syntax. After configuring the device name column and specifying the data type, we end up reading the data on SeaTunnel in the format shown above, containing the Time, device column, and the actual data value. This makes it possible to read data from the same device in bulk.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="parallel-reading">Parallel reading<a class="hash-link" href="#parallel-reading" title="Direct link to heading">​</a></h2><p>The other is a parallel read.</p><ul><li><p>Split
We have scoped the table by the Time column and if we are reading in parallel we may want to scope the table to allow parallel threads/processes to read a specific range of data. By configuring the three parameters, the end result will be a query SQL, where the original SQL is divided into different splits with query conditions to achieve the actual read SQL.</p></li><li><p>Allocate Split to the reader
Once the split is done, there is an allocation logic to follow in order to distribute it to each parallel reader.</p></li></ul><p><img loading="lazy" src="/assets/images/16714319281280-dfc833cfbd8315f969c518271cd38e95.jpg" width="720" height="162"></p><p>This logic is based on the ID of the split to the reader, which may be more random, or more uniform if the ID of the split is more hashed, depending on the Connector.</p><p><img loading="lazy" src="/assets/images/16714319372730-361662ffb0d74adea0f64073bf2cf44f.jpg" width="720" height="528"></p><p>The result achieved is shown in the picture.</p><h1>Status recovery</h1><p>There is also state recovery involved when reading because if the task is large, the reading will take longer, and if there is an error or exception in the middle, you have to consider how to recover the state from the point where the error occurred, and then read it again afterward.</p><p><img loading="lazy" src="/assets/images/16714319281280-dfc833cfbd8315f969c518271cd38e95.jpg" width="720" height="162">
<img loading="lazy" src="/assets/images/16714319569097-2f328036d7363eb6b0d3678984d78af0.jpg" width="720" height="268">
<img loading="lazy" src="/assets/images/16714319599521-13dc977f614b93a4db1eed15ee1e4f30.jpg" width="720" height="256"></p><p>SeaTunnel’s state recovery is mainly through the reader storing the unread Split information into the state, and then the engine will periodically take a snapshot of the state when reading so that we can restore the last snapshot when we recover and continue reading afterward.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="iotdb-connector-data-write-analysis">IoTDB Connector Data Write Analysis<a class="hash-link" href="#iotdb-connector-data-write-analysis" title="Direct link to heading">​</a></h2><p>The next step is the parsing of the data writes.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="data-type-mapping-1">Data type mapping<a class="hash-link" href="#data-type-mapping-1" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714319862080-244a507b57e8568444d4ead4b29349aa.jpg" width="720" height="457"></p><p>Data writing also involves data type mapping, but here, in contrast to data reading, it maps the SeaTunnel data types to the IoTDB data types. As IoTDB only has INT32, the writing process involves lifting the data types TINYINT and SMALLINT. All other data types can be converted one-to-one; ARRAY and VECTOR data types are not yet supported.</p><p><img loading="lazy" src="/assets/images/16714319949478-1f6dc7ae103ae0ab3852b1350c74f659.jpg" width="720" height="574"></p><p>The above diagram shows the corresponding code, the implementation logic will need to be seen in our specific mapping.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="dynamic-injection-of-metadata">Dynamic injection of metadata<a class="hash-link" href="#dynamic-injection-of-metadata" title="Direct link to heading">​</a></h2><p>SeaTunnel supports the dynamic injection of metadata.</p><p>When heterogeneous data sources are written to the IoTDB, device, measurement, and time are extracted from each row of data, either by serializing the SeaTunnelRow with a fixed column value as configured. Alternatively, the system time can be used as the time, or the current system time can be populated if no time column is specified, and the storage group can be configured to be automatically appended to the device prefix.</p><p><img loading="lazy" src="/assets/images/16714320117277-aca2fc93f15601665ef8fd53529953fa.jpg" width="720" height="180"></p><p>For example, suppose that the structure of a row in SeaTunnel reading the data format shown above can be configured to synchronize to the IoTDB and the result obtained is as follows.</p><p><img loading="lazy" src="/assets/images/16714320201848-d017fa8600fc03c9e77914a53c961557.jpg" width="720" height="197"></p><p>The temperature and humidity columns we need were extracted, and ts and device names were extracted as the original data for the IoTDB.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="batch-commits-and-exception-retries">Batch commits and exception retries<a class="hash-link" href="#batch-commits-and-exception-retries" title="Direct link to heading">​</a></h2><p>In addition, Sink needs to handle batch and retry when writing. For batches, we can configure the appropriate batch configuration, including support for configuring the number and interval of batch commits; if the data is cached to memory, you can enable a separate thread for timed commits.</p><p>For retries, SeaTunnel supports the configuration of the number of retries, the waiting interval and the maximum number of retries, as well as the possibility to end a retry if it encounters a non-recoverable error when it has finished.</p><p><img loading="lazy" src="/assets/images/16714320394193-27ad106e26762595d5b919019bd72550.jpg" width="720" height="466"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="iotdb-connector-usage-examples">IoTDB Connector Usage Examples<a class="hash-link" href="#iotdb-connector-usage-examples" title="Direct link to heading">​</a></h2><p>After the previous analysis of reading and writing data, let’s look at three typical examples of usage scenarios.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="exporting-data-from-iotdb">Exporting data from IoTDB<a class="hash-link" href="#exporting-data-from-iotdb" title="Direct link to heading">​</a></h2><p>The first scenario is exporting data from the IoTDB, the example I have given here is reading data from the IoTDB to the Console.</p><ul><li>Read in parallel, output to Console</li></ul><p>Parallelism: 2</p><p>Number of batches: 24</p><p>Time frame: 2022–09–25 ~ 2022–09–26
<img loading="lazy" src="/assets/images/16714320856052-31c7463162a38c89034e9a14813d4686.jpg" width="720" height="247"></p><p>Let’s assume that we have a data table in IoTDB and we want to export the data to the Console. The whole configuration is shown above and needs to map the columns of data we want to export and the time range to check.</p><p>This is the simplest example, but in practice, the Sink side may be more complex, so you will need to refer to the documentation of the corresponding data source for the appropriate configuration.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="importing-data-to-iotdb">Importing data to IoTDB<a class="hash-link" href="#importing-data-to-iotdb" title="Direct link to heading">​</a></h2><ul><li>Read database, batch write to IoTDB<ul><li>Batch writing: one commit every 1024 entries or every 1000 ms</li><li>-Extracting metadata device, timestamp, measurement</li><li>-Specify the storage group: root.test_group</li></ul></li></ul><p><img loading="lazy" src="/assets/images/16714321290339-3c0479957e9a28da554374f5c8d4f426.jpg" width="720" height="284">
Another typical usage scenario is to import data from other data sources into IoTDB. suppose I have an external database table with columns like ts, temperature, humidity, etc. and we import it into IoTDB, requiring the columns of temperature and humidity, but the rest can be left out. The whole configuration is shown in the diagram above, you can refer to it.</p><p>On the Sink side, you mainly have to specify the Key of the device column, such as from which data the device is extracted, from which class the time is extracted, which columns to write to the IoTDB, etc.</p><p>As you can see, we can configure the storage group, which is the storage group of the IoTDB, which can be specified by the storage group.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="synchronizing-data-between-iotdb">Synchronizing data between IoTDB<a class="hash-link" href="#synchronizing-data-between-iotdb" title="Direct link to heading">​</a></h2><p>The third scenario is to synchronize data between IoTDB and IoTDB and write to IoTDB in bulk, suppose there is a table in IoTDB that needs to be synchronized to another IoTDB, after synchronization the storage group has changed and the name of the indicator of the data column has also changed, then you can use projection to rewrite the indicator name and use SQL to rewrite the storage group.</p><p><img loading="lazy" src="/assets/images/16714321480992-670f922b9dbe990571115d671159bb22.jpg" width="720" height="309"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="how-to-get-involved-in-contribution">How to get involved in contribution<a class="hash-link" href="#how-to-get-involved-in-contribution" title="Direct link to heading">​</a></h2><p>Finally, a few words about the next steps for the IoTDB Connector and how you can get involved in improving the Connector and contributing new features that are needed.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="next-steps-for-the-iotdb-connector">Next steps for the IoTDB Connector<a class="hash-link" href="#next-steps-for-the-iotdb-connector" title="Direct link to heading">​</a></h2><ul><li>Support for reading and writing vector data types</li><li>Support for tsfile reads and writes</li><li>Support for writing tsfile and reloading to IoTDB</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/Apache SeaTunnel Committer | Zongwen Li">SeaTunnel engine, designed for tens-of-billions data integration</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-12-09T00:00:00.000Z" itemprop="datePublished">December 9, 2022</time> · <!-- -->10 min read</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/assets/images/16714309876928-859e41ec15f205a23a1b25d8a2b80046.jpg" width="720" height="306">
Apache SeaTunnel Committer | Zongwen Li</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="introduction-to-apache-seatunnel">Introduction to Apache SeaTunnel<a class="hash-link" href="#introduction-to-apache-seatunnel" title="Direct link to heading">​</a></h2><p>Apache SeaTunnel is a very easy-to-use ultra-high-performance distributed data integration platform that supports real-time synchronization of massive data.</p><p>Apache SeaTunnel will try its best to solve the problems that may be encountered in the process of mass data synchronization, such as data loss and duplication, task accumulation and delay, low throughput, etc.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="milestones-of-seatunnel">Milestones of SeaTunnel<a class="hash-link" href="#milestones-of-seatunnel" title="Direct link to heading">​</a></h2><p>SeaTunnel, formerly known as Waterdrop, was open-sourced on GitHub in 2017.</p><p>In October 2021, the Waterdrop community joined the Apache incubator and changed its name to SeaTunnel.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-growth">SeaTunnel Growth<a class="hash-link" href="#seatunnel-growth" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714310892722-67ccd10c8545d757fc1dab589404be3d.jpg" width="720" height="469">
<img loading="lazy" src="/assets/images/16714310916195-8701b0e12c30eae7063696ec13464375.jpg" width="720" height="378">
<img loading="lazy" src="/assets/images/16714310939883-8df5afa031f552b198757dc4dbe0bf70.jpg" width="720" height="392">
When SeaTunnel entered the Apache incubator, the SeaTunnel community ushered in rapid growth.</p><p>As of now, the SeaTunnel community has a total of 151 contributors, 4314 Stars, and 804 forks.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="pain-points-of-existing-engines">Pain points of Existing engines<a class="hash-link" href="#pain-points-of-existing-engines" title="Direct link to heading">​</a></h2><p>There are many pain points faced by the existing computing engines in the field of data integration, and we will talk about this first. The pain points usually lie in three directions:</p><ul><li>The fault tolerance ability of the engine;</li><li>Difficulty in configuration, operation, and maintenance of engine jobs;</li><li>The resource usage of the engine.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="fault-tolerance">fault tolerance<a class="hash-link" href="#fault-tolerance" title="Direct link to heading">​</a></h2><p>Global Failover
<img loading="lazy" alt="Global-failover" src="/assets/images/16714311670656-14b472dd8abdeff2639c1701ed9997f9.jpg" width="720" height="176">
For distributed streaming processing systems, high throughput and low latency are often the most important requirements. At the same time, fault tolerance is also very important in distributed systems. For scenarios that require high correctness, the implementation of exactly once is often very important.</p><p>In a distributed streaming processing system, since the computing power, network, load, etc. of each node are different, the state of each node cannot be directly merged to obtain a true global state. To obtain consistent results, the distributed processing system needs to be resilient to node failure, that is, it can recover to consistent results when it fails.</p><p>Although it is claimed in their official blog that Spark’s Structured Streaming uses the Chandy-Lamport algorithm for Failover processing, it does not disclose more details.</p><p>Flink implemented Checkpoint as a fault-tolerant mechanism based on the above algorithm and published related papers: Lightweight Asynchronous Snapshots for Distributed Dataflows</p><p>In the current industrial implementation, when a job fails, all nodes of the job DAG need to failover, and the whole process will last for a long time, which will cause a lot of upstream data to accumulate.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="loss-of-data">Loss of Data<a class="hash-link" href="#loss-of-data" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714312426416-f778eaa67ecf527449353404cf0bf421.jpg" width="720" height="175">
The previous problem will cause a long-time recovery, and the business service may accept a certain degree of data delay.</p><p>In a worse case, a single sink node cannot be recovered for a long time, and the source data has a limited storage time, such as MySQL and Oracle log data, which will lead to data loss.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="configuration-is-cumbersome">Configuration is cumbersome<a class="hash-link" href="#configuration-is-cumbersome" title="Direct link to heading">​</a></h2><p>Single table Configuration</p><p><img loading="lazy" src="/assets/images/16714312637015-abff06af8bf814cbb39e2fddfd5b0271.jpg" width="720" height="360">
The previous examples are cases regarding a small number of tables, but in real business service development, we usually need to synchronize thousands of tables, which may be divided into databases and tables at the same time;</p><p>The status quo is that we need to configure each table, a large number of table synchronization takes a lot of time for users, and it is prone to problems such as field mapping errors, which are difficult to maintain.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="not-supporting-schema-evolution">Not supporting Schema Evolution<a class="hash-link" href="#not-supporting-schema-evolution" title="Direct link to heading">​</a></h2><p><img loading="lazy" alt="Not-supports-DDL" src="/assets/images/16714312769761-80425f8f27f3efc3ab62487814dad59e.jpg" width="720" height="360">
Besides, according to the research report of Fivetran, 60% of the company’s schema will change every month, and 30% will change every week.</p><p>However, none of the existing engines supports Schema Evolution. After changing the Schema each time, the user needs to reconfigure the entire link, which makes the maintenance of the job very cumbersome.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-high-volume-of-resource-usage">The high volume of resource usage<a class="hash-link" href="#the-high-volume-of-resource-usage" title="Direct link to heading">​</a></h2><p>The database link takes up too much</p><p><img loading="lazy" src="/assets/images/16714313100541-98837b408ddcd3e5d7114421e893de80.jpg" width="720" height="480">
If our Source or Sink is of JDBC type, since the existing engine only supports one or more links per table, when there are many tables to be synchronized, more link resources will be occupied, which will bring a great burden to the database server.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="operator-pressure-is-uncontrollable">Operator pressure is uncontrollable<a class="hash-link" href="#operator-pressure-is-uncontrollable" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714313301435-5d797838b956772428477a7a26a2591c.jpg" width="720" height="333">
In the existing engine, a buffer and other control operators are used to control the pressure, that is, the back pressure mechanism; since the back pressure is transmitted level by level, there will be pressure delay, and at the same time, the processing of data will not be smooth enough, increasing the GC time, fault-tolerant completion time, etc.</p><p>Another case is that neither the source nor the sink has reached the maximum pressure, but the user still needs to control the synchronization rate to prevent too much impact on the source database or the target database, which cannot be controlled through the back pressure mechanism.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="architecture-goals-of-apache-seatunnel-engine">Architecture goals of Apache SeaTunnel Engine<a class="hash-link" href="#architecture-goals-of-apache-seatunnel-engine" title="Direct link to heading">​</a></h2><p>To solve these severe issues faced by computing engines, we self-developed our engine expertise in big data integration.</p><p>Firstly, let’s get through what goals this engine wants to achieve.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="pipeline-failover">Pipeline Failover<a class="hash-link" href="#pipeline-failover" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714313559400-d6029daeb8672d49a5bfb8718c518e3f.jpg" width="720" height="176">
In the data integration case, there is a possibility that a job can synchronize hundreds of sheets, and the failure of one node or one table will lead to the failure of all tables, which is too costly.</p><p>We expect that unrelated Job Tasks will not affect each other during fault tolerance, so we call a vertex collection with upstream and downstream relationships a Pipeline, and a Job can consist of one or more pipelines.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="regional-failover">Regional Failover<a class="hash-link" href="#regional-failover" title="Direct link to heading">​</a></h2><p>Now if there is an exception in the pipeline, we still need to failover all the vertex in the pipeline; but can we restore only part of the vertex?
<img loading="lazy" src="/assets/images/16714313919617-100427ea7efcebd349ce998e13a8c0a0.jpg" width="720" height="176">
For example, if the Source fails, the Sink does not need to restart. In the case of a single Source and multiple Sinks, if a single Sink fails, only the Sink and Source that failed will be restored; that is, only the node that failed and its upstream nodes will be restored.</p><p>Obviously, the stateless vertex does not need to be restarted, and since SeaTunnel is a data integration framework, we do not have aggregation state vertexes such as Agg and Count, so we only need to consider Sink;</p><ul><li>Sink does not support idempotence &amp; 2PC; no restart and restart will result in the same data duplication, which can only be solved by Sink without restarting;</li><li>Sink supports idempotence, but does not support 2PC: because it is idempotent writing, it does not matter whether the source reads data inconsistently every time, and it does not need to be restarted;</li><li>Sink supports 2PC:</li><li>If the Source supports data consistency, if an abort is not executed, the processed old data will be automatically ignored through the channel data ID, and at the same time, it will face the problem that the transaction session time may time out;</li><li>If the Source does not support data consistency, perform abort on the Sink to discard the last data, which has the same effect as restarting but does not require initialization operations such as re-establishing links;</li><li>That is, the simplest implementation is to execute abort.
We use the pipeline as the minimum granularity for fault-tolerant management, and use the Chandy-Lamport algorithm to realize fault-tolerant distributed jobs.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="data-cache">Data Cache<a class="hash-link" href="#data-cache" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714314318184-95b8b08ab40b5d0da4ca1bd2e659f965.jpg" width="720" height="175">
For sink failure, when data cannot be written, a possible solution is to work two jobs at the same time.</p><p>One job reads the database logs using the CDC source connector and then writes the data to Kafka using the Kafka Sink connector. Another job reads data from Kafka using the Kafka source connector and writes data to the destination using the destination sink connector.</p><p>This solution requires users to have a deep understanding of the underlying technology, and both tasks will increase the difficulty of operation and maintenance. Because every job needs JobMaster, it requires more resources.</p><p>Ideally, the user only knows that they will be reading data from the source and writing data to the sink, and at the same time, during this process, the data can be cached in case the sink fails. The sync engine needs to automatically add caching operations to the execution plan and ensure that the source still works in the event of a sink failure. In this process, the engine needs to ensure that the data written to the cache and read from the cache are transactional, to ensure data consistency.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="sharding--multi-table-sync">Sharding &amp; Multi-table Sync<a class="hash-link" href="#sharding--multi-table-sync" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714314489916-cd0b185b6626a8c1598aa3ac569ecdbd.jpg" width="720" height="448"></p><p>For a large number of table synchronization, we expect that a single Source can support reading multiple structural tables, and then use the side stream output to keep consistent with a single table stream.</p><p>The advantage of this is that it can reduce the link occupation of the data source and improve the utilization rate of thread resources.</p><p>At the same time, in SeaTunnel Engine, these multiple tables will be regarded as a pipeline, which will increase the granularity of fault tolerance; there are trade-offs, and the user can choose how many tables a pipeline can pass through.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="schema-evolution">Schema Evolution<a class="hash-link" href="#schema-evolution" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714314658701-b97c66b4a4eacfe54acf2e5ea6cc001b.jpg" width="720" height="199">
Schema Evolution is a feature that allows users to easily change the current schema of a table to accommodate changing data over time. Most commonly, it is used when performing an append or overwrite operation, to automatically adjust the schema to include one or more new columns.</p><p>This feature is required for real-time data warehouse scenarios. Currently, the Flink and Spark engines do not support this feature.</p><p>In SeaTunnel Engine, we will use the Chandy-Lamport algorithm to send DDL events, make them flow in the DAG graph and change the structure of each operator, and then synchronize them to the Sink.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="shared-resource">Shared Resource<a class="hash-link" href="#shared-resource" title="Direct link to heading">​</a></h2><p><img loading="lazy" alt="Shared-resource" src="/assets/images/16714314806989-3f0543f4a2b9412e0d6c48eb1b7aa5c1.jpg" width="720" height="455">
The Multi-table feature can reduce the use of some Source and Sink link resources. At the same time, we have implemented Dynamic Thread Resource Sharing in SeaTunnel Engine, reducing the resource usage of the engine on the server.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="speed-control">Speed Control<a class="hash-link" href="#speed-control" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714315001348-d6e97c70a71c7f4b9220a68751cb1401.jpg" width="720" height="323">
As for the problems that cannot be solved by the back pressure mechanism, we will optimize the Buffer and Checkpoint mechanism:</p><ul><li>Firstly, We try to allow Buffer to control the amount of data in a period;</li><li>Secondly, by the Checkpoint mechanism, the engine can lock the buffer after the Checkpoint reaches the maximum number of parallelism and executes an interval time, prohibiting the writing of Source data, achieving the result of taking the pressure proactively, avoiding issues like back pressure delay or failure to be delivered to Source.
The above is the design goal of SeaTunnel Engine, hoping to help you better solve the problems that bother you in data integration. In the future, we will continue to optimize the experience of using SeaTunnel so that more people are willing to use it.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-future-of-apache-seatunnel">The future of Apache SeaTunnel<a class="hash-link" href="#the-future-of-apache-seatunnel" title="Direct link to heading">​</a></h2><p>As an Apache incubator project, the Apache SeaTunnel community is developing rapidly. In the following community planning, we will focus on four directions:</p><p>Support more data integration scenarios (Apache SeaTunnel Engine)
It is used to solve the pain points that existing engines cannot solve, such as the synchronization of the entire database, the synchronization of table structure changes, and the large granularity of task failure;</p><blockquote><p>Guys who are interested in the engine can pay attention to this Umbrella: <a href="https://github.com/apache/incubator-seatunnel/issues/2272" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/2272</a></p></blockquote><p>Expand and improve Connector &amp; Catalog ecology
Support more Connector &amp; Catalog, such as TiDB, Doris, Stripe, etc., and improve existing connectors, improve their usability and performance, etc.;
Support CDC connector for real-time incremental synchronization scenarios.</p><blockquote><p>Guys who are interested in connectors can pay attention to this Umbrella: <a href="https://github.com/apache/incubator-seatunnel/issues/1946" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/1946</a></p></blockquote><p>Support for more versions of the engines
Such as Spark 3.x, Flink 1.14.x, etc.</p><blockquote><p>Guys who are interested in supporting Spark 3.3 can pay attention to this PR: <a href="https://github.com/apache/incubator-seatunnel/pull/2574" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2574</a></p></blockquote><p>Easier to use (Apache SeaTunnel Web)
Provides a web interface to make operations more efficient in the form of DAG/SQL Simple and more intuitive display of Catalog, Connector, Job, etc.;
Access to the scheduling platform to make task management easier</p><blockquote><p>Guys who are interested in Web can pay attention to our Web sub-project: <a href="https://github.com/apache/incubator-seatunnel-web" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel-web</a></p></blockquote></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/During the joint Apache SeaTunnel &amp; IoTDB Meetup on October 15,">Mafengwo finally chose Apache SeaTunnel after analyzing these 9 points of how it works!</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-11-17T00:00:00.000Z" itemprop="datePublished">November 17, 2022</time> · <!-- -->19 min read</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/assets/images/16714322908857-c6ce9a962f477d13b5480206b583b6d2.jpg" width="720" height="480"></p><p><img loading="lazy" src="/assets/images/16714322944041-351d2ac6aa565d636c97a1ad6b0c136e.jpg" width="360" height="309">
Bo Bi, data engineer at Mafengwo</p><blockquote><p>During the joint Apache SeaTunnel &amp; IoTDB Meetup on October 15, Bo Bi, the data engineer at a leading Chinese travel-social e-commerce platform Mafengwo, introduced the basic principles of SeaTunnel and related enterprise practice thinking, the pain points and optimization thinking in typical scenarios of Mafengwo’s big data development and scheduling platform, and shared his experience of participating in community contributions. We hope to help you understand SeaTunnel and the paths and skills of community building at the same time.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="introduction-to-the-technical-principle-of-seatunnel">Introduction to the technical principle of SeaTunnel<a class="hash-link" href="#introduction-to-the-technical-principle-of-seatunnel" title="Direct link to heading">​</a></h2><p>SeaTunnel is a distributed, high-performance data integration platform for the synchronization and transformation of large volumes of data (offline and real-time)</p><p>The diagram above shows the workflow of SeaTunnel, which in simple terms consists of 3 parts: input, transformation, and output; more complex data processing is just a combination of several actions.</p><p>In a synchronization scenario, such as importing Kafka to Elasticsearch, Kafka is the Source of the process and Elasticsearch is the Sink of the process.</p><p>If, during the import process, the field columns do not match the external data columns to be written and some column or type conversion is required, or if you need to join multiple data sources and then do some data widening, field expansion, etc., then you need to add some Transform in the process, corresponding to the middle part of the picture.</p><p><img loading="lazy" src="/assets/images/16714323322988-74b7a47d1a3299efd23c6375d3acaa5e.jpg" width="660" height="781">
This shows that the core of SeaTunnel is the Source, Transform and Sink process definitions.</p><p>In Source we can define the data sources we need to read, in Sink, we can define the data pipeline and eventually write the external storage, and we can transform the data in between, either using SQL or custom functions.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-connector-api-version-v1-architecture-breakdown">SeaTunnel Connector API Version V1 Architecture Breakdown<a class="hash-link" href="#seatunnel-connector-api-version-v1-architecture-breakdown" title="Direct link to heading">​</a></h2><p>For a mature component framework, there must be something unique about the design pattern of the API design implementation that makes the framework scalable.</p><p>The SeaTunnel architecture consists of three main parts.</p><p>1、SeaTunnel Basic API.</p><ol><li><p>the implementation of the SeaTunnel base API.</p></li><li><p>SeaTunnel’s plug-in system.</p></li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-basic-api">SeaTunnel Basic API<a class="hash-link" href="#seatunnel-basic-api" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714323668557-9c9260e0c54017b5282b1294ccc9c692.jpg" width="720" height="194">
The above diagram shows the definition of the interface, the Plugin interface in SeaTunnel abstracts the various actions of data processing into a Plugin.</p><p>The five parts of the diagram below, Basesource, Basetransfform, Basesink, Runtimeenv, and Execution, all inherit from the Plugin interface.
<img loading="lazy" src="/assets/images/16714323741126-a61ed7b20a44b14b78d39c7ffe42ec41.jpg" width="720" height="229"></p><p>As a process definition plug-in, Source is responsible for reading data, Transform is responsible for transforming, Sink is responsible for writing and Runtimeenv is setting the base environment variables.</p><p>The overall SeaTunnel base API is shown below</p><p><img loading="lazy" src="/assets/images/16714323846302-eabb8409469fa34d9b0ebd2402fca23d.jpg" width="720" height="347">
Execution, the data flow builder used to build the entire data flow based on the first three, is also part of the base API</p><p><img loading="lazy" src="/assets/images/16714323920717-b5bb28d92939847f1f30c61b6895191a.jpg" width="720" height="192"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-base-api-implementation">SeaTunnel Base API Implementation<a class="hash-link" href="#seatunnel-base-api-implementation" title="Direct link to heading">​</a></h2><p>Based on the previous basic APIs, SeaTunnel has been implemented in separate packages for different computing engines, currently the Spark API abstraction and the Flink API abstraction, which logically completes the process of building the data pipeline.</p><p><img loading="lazy" src="/assets/images/16714323741126-a61ed7b20a44b14b78d39c7ffe42ec41.jpg" width="720" height="229"></p><p>Due to space constraints, we will focus on Spark batch processing. Based on the wrapped implementation of the previous base Api, the first is that Base spark source implements Base source, base Spark transform implements Base transform and Base Spark sink implements Base sink.</p><p>The method definition uses Spark’s Dataset as the carrier of the data, and all data processing is based on the Dataset, including reading, processing and exporting.</p><p>The SparkEnvironment, which internally encapsulates Spark’s Sparksession in an Env, makes it easy for individual plugins to use.</p><p><img loading="lazy" src="/assets/images/16714324136843-44e65c36b7ef55c34b50a9eb0e43c3cc.jpg" width="720" height="350"></p><p>The Spark batch process ends with SparkBatchExecution (the data stream builder), which is the core code snippet used to functionally build our data stream Pipeline, the most basic data stream on the left in the diagram below.</p><p>The user-based definition of each process component is also the configuration of Source Sink, Transform. More complex data flow logic can be implemented, such as multi-source Join, multi-pipeline processing, etc., all of which can be built through Execution.</p><p><img loading="lazy" src="/assets/images/16714324237449-e5a12e608045d5a153853c93eb844852.jpg" width="720" height="405"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-connector-v1-api-architecture-summary">SeaTunnel Connector V1 API Architecture Summary<a class="hash-link" href="#seatunnel-connector-v1-api-architecture-summary" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714324336701-6e5cadce0d1a1858d7bffbf96c5cae82.jpg" width="720" height="405">
SeaTunnel’s API consists of three main parts.</p><p>The first part is the SeaTunnel base API, which provides the basic abstract interfaces such as Source, Sink, Transform, and Plugin.</p><p>The second part is based on a set of interfaces Transform, Sink, Source, Runtime, and Execution provided by the SeaTunnel base API, which is wrapped and implemented on the Flink and Spark engines respectively, i.e. Spark engine API layer abstraction and Flink engine API layer abstraction.</p><p>Both Flink and Spark engines support stream and batch processing, so there are different ways to use streams/batches under the Flink API abstraction and Spark abstraction APIs, such as Flinkstream and Flinkbatch under the Flink abstraction API, and Sparkbatch and Sparkstreaming under the Spark abstraction API.</p><p>The third part is the plug-in system, based on Spark abstraction and Flink API abstraction, SeaTunnel engine implements rich connectors and processing plug-ins, while developers can also be based on different engine API abstractions, and extensions to achieve their own Plugin.</p><p>SeaTunnel Implementation Principle
Currently, SeaTunnel offers a variety of ways to use Flink, Spark, and FlinkSQL. Due to space limitations, we will introduce the execution principles of the Spark method.</p><p>First, the entry starts the command Start-seatunnel-spark.sh via the shell, which internally calls Sparkstarter’s Class, which parses the parameters passed by the shell script, and also parses the Config file to determine which Connectors are defined in the Config file, such as Fake, Console, etc.
<img loading="lazy" src="/assets/images/16714324454477-200fd76badcfc17bdd291f364c70a191.jpg" width="720" height="405">
Then find the Connector path from the Connector plugin directory and stitch it into the Spark-submit launch command with — jar, so that the found Plugin jar package can be passed to the Spark cluster as a dependency.</p><p>For Connector plugins, all Spark Connectors are packaged in the plugin directory of the distribution (this directory is managed centrally).</p><p>After Spark-submit is executed, the task is submitted to the Spark cluster, and the Main class of the Spark job’s Driver builds the data flow Pipeline through the data flow builder Execution, combined with Souce, Sink, and Transform so that the whole chain is connected.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-connector-v2-api-architecture">SeaTunnel Connector V2 API Architecture<a class="hash-link" href="#seatunnel-connector-v2-api-architecture" title="Direct link to heading">​</a></h2><p>In the latest community release of SeaTunnel 2.2.0-beta, the refactoring of the Connectorapi, now known as the SeaTurnelV2 API, has been completed!</p><p>Why do we need to reconfigure?</p><p>As the Container is currently a strongly coupled engine, i.e. Flink and Spark API, if the Flink or Spark engine is upgraded, the Connector will also have to be adjusted, possibly with changes to parameters or interfaces.</p><p>This can lead to multiple implementations for different engines and inconsistent parameters to develop a new Connector. Therefore, the community has designed and implemented the V2 version of the API based on these pain points.</p><p><img loading="lazy" src="/assets/images/16714324726276-11d9d5c6d4e848796fa71329819caa72.jpg" width="720" height="405"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-v2-api-architecture">SeaTunnel V2 API Architecture<a class="hash-link" href="#seatunnel-v2-api-architecture" title="Direct link to heading">​</a></h2><p>SeaTunnel V2 API Architecture</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="1table-api">1.Table API<a class="hash-link" href="#1table-api" title="Direct link to heading">​</a></h3><p>·DataType: defines SeaTunnel’s data structure SeaTunnelRow, which is used to isolate the engine</p><p>·Catalog: used to obtain Table Scheme, Options, etc..</p><p>·Catalog Storage: used to store user-defined Table Schemes etc. for unstructured engines such as Kafka.</p><p>·Table SPI: mainly used to expose the Source and Sink interfaces as an SPI</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-source--sink-api">2. Source &amp; Sink API<a class="hash-link" href="#2-source--sink-api" title="Direct link to heading">​</a></h3><p>Define the Connector’s core programming interface for implementing the Connector</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="3engine-api">3.Engine API<a class="hash-link" href="#3engine-api" title="Direct link to heading">​</a></h3><p>·Translation: The translation layer, which translates the Source and Sink APIs implemented by the Connector into a runnable API inside the engine.</p><p>·Execution: Execution logic, used to define the execution logic of Source, Transform, Sink and other operations within the engine.</p><p>The Source &amp; Sink API is the basis for the implementation of the connector and is very important for developers.</p><p>The design of the v2 Source &amp; Sink API is highlighted below</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-connector-v2-source-api">SeaTunnel Connector V2 Source API<a class="hash-link" href="#seatunnel-connector-v2-source-api" title="Direct link to heading">​</a></h2><p>The current version of SeaTunnel’s API design draws on some of Flink’s design concepts, and the more core classes of the Source API are shown below.</p><p><img loading="lazy" src="/assets/images/16714325444078-fbed659c615c445655896b93a093177f.jpg" width="720" height="405">
<img loading="lazy" src="/assets/images/16714325474972-48cbee3672ad2f32317d48263f204978.jpg" width="720" height="405">
The core Source API interaction flow is shown above. In the case of concurrent reads, the enumerator SourceSplitEnumerator is required to split the task and send the SourceSplit down to the SourceReader, which receives the split and uses it to read the external data source.</p><p>In order to support breakpoints and Eos semantics, it is necessary to preserve and restore the state, for example by preserving the current Reader’s Split consumption state and restoring it after a failure in each Reader through the Checkpoint state and Checkpoint mechanism, so that the data can be read from the place where it failed.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-connector-v2-sink-api">SeaTunnel Connector V2 Sink API<a class="hash-link" href="#seatunnel-connector-v2-sink-api" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714325600316-f066630b909ec30a7727b7877a4838b0.jpg" width="720" height="405">
The overall Sink API interaction flow is shown in the diagram below. The SeaTunnel sink is currently designed to support distributed transactions, based on a two-stage transaction commit.</p><p>First SinkWriter continuously writes data to an external data source, then when the engine does a checkpoint, it triggers a first-stage commit.</p><p>SinkWriter needs to do a Prepare commit, which is the first stage of the commit.</p><p>The engine will determine if all the Writer&#x27;s first stage succeeds, and if they all succeed, the engine will combine the Subtask’s Commit info with the Commit method of the Committer to do the actual commit of the transaction and operate the database for the Commit, i.e. the second stage of the commit. This is the second stage of commit.</p><p><img loading="lazy" src="/assets/images/16714325681738-973c53bd86223df4ee98cbb2ecb30eaf.jpg" width="570" height="814">
For the Kafka sink connector implementation, the first stage is to do a pre-commit by calling KafkaProducerSender.prepareCommit().</p><p>The second commit is performed via Producer.commitTransaction();.</p><p>flush(); flushes the data from the Broker’s system cache to disk.</p><p>Finally, it is worth noting!</p><p>Both SinkCommitter and SinkAggregatedCommitter can perform a second stage commit to replace the Committer in the diagram. The difference is that SinkCommitter can only do a partial commit of a single Subtask’s CommitInfo, which may be partially successful and partially unsuccessful, and cannot be handled globally. The difference is that the SinkCommitter can only do partial commits of a single Subtask’s CommitInfo, which may be partially successful and partially unsuccessful.</p><p>SinkAggregatedCommitter is a single parallel, aggregating the CommitInfo of all Subtask, and can do the second stage commit as a whole, either all succeed or all fail, avoiding the problem of inconsistent status due to partial failure of the second stage.</p><p>It is therefore recommended that the SinkAggregatedCommitter be used in preference.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="comparison-of-seatunnel-v1-and-v2-api-processing-flows">Comparison of SeaTunnel V1 and V2 API processing flows<a class="hash-link" href="#comparison-of-seatunnel-v1-and-v2-api-processing-flows" title="Direct link to heading">​</a></h2><p>We can look at the changes before and after the V1 V2 upgrade from a data processing perspective, which is more intuitive, Spark batch processing as an example: SeaTunnel V1: The entire data processing process is based on the Spark dataset API, and the Connector and the compute engine are strongly coupled.</p><p><img loading="lazy" src="/assets/images/16714325887598-d27009789ff28e56c8bfcca29bcedfe1.jpg" width="720" height="405">
SeaTunnel V2: Thanks to the work of the engine translator, the Connector API, and the SeaTunnelRow, the data source of the SeaTunnel internal data structures accessed through the Connector, are translated by the translation layer into a runnable Spark API and spark dataset that is recognized inside the engine during data transformation.</p><p>As data is written out, the Spark API and Spark dataset are translated through the translation layer into an executable connector API inside the SeaTunnel connector and a data source of internal SeaTunnel structures that can be used.</p><blockquote><p>Overall, the addition of a translation layer at the API and compute engine layers decouples the Connector API from the engine, and the Connector implementation no longer depends on the compute engine, making the extension and implementation more flexible.</p></blockquote><blockquote><p>In terms of community planning, the V2 API will be the main focus of development, and more features will be supported in V2, while V1 will be stabilized and no longer maintained.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="practice-and-reflections-on-our-off-line-development-scheduling-platform">Practice and reflections on our off-line development scheduling platform<a class="hash-link" href="#practice-and-reflections-on-our-off-line-development-scheduling-platform" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="practice-and-reflections-on-our-off-line-development-scheduling-platform-1">Practice and reflections on our off-line development scheduling platform<a class="hash-link" href="#practice-and-reflections-on-our-off-line-development-scheduling-platform-1" title="Direct link to heading">​</a></h3><p><img loading="lazy" src="/assets/images/16714326227360-bcd55d2c5b7b23ec91a5d1e27c04fb0e.jpg" width="720" height="405">
Hornet’s Nest Big Data Development Platform, which focuses on providing one-stop big data development and scheduling services, helps businesses solve complex problems such as data development management, task scheduling and task monitoring in offline scenarios.</p><p>The offline development and scheduling platform plays the role of the top and the bottom. The top is to provide open interface API and UI to connect with various data application platforms and businesses, and the bottom is to drive various computations and storage, and then run in an orderly manner according to the task dependency and scheduling time.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="platform-capabilities">Platform Capabilities<a class="hash-link" href="#platform-capabilities" title="Direct link to heading">​</a></h2><p><strong>Data development</strong></p><p>Task configuration, quality testing, release live</p><p><strong>·Data synchronisation</strong></p><p>Data access, data processing, data distribution</p><p><strong>·Scheduling capabilities</strong></p><p>Supports timed scheduling, triggered scheduling</p><p><strong>·Operations and Maintenance Centre
</strong>
Job Diagnosis, Task O&amp;M, Instance O&amp;M</p><p><strong>·Management</strong></p><p>Library table management, permission management, API management, script management</p><p>In summary, the core capabilities of the offline development scheduling platform are openness, versatility, and one-stop shopping. Through standardized processes, the entire task development cycle is managed and a one-stop service experience is provided.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-architecture-of-the-platform">The architecture of the platform<a class="hash-link" href="#the-architecture-of-the-platform" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/16714326749427-2957d8414a3175ed8cc46bde32a08565.jpg" width="720" height="405">
The Hornet’s Nest Big Data Development and Scheduling Platform consists of four main modules: the task component layer, the scheduling layer, the service layer, and the monitoring layer.</p><p>The service layer is mainly responsible for job lifecycle management (e.g. job creation, testing, release, offline); Airflow dagphthon file building and generating, task bloodline dependency management, permission management, API (providing data readiness, querying of task execution status).</p><p>The scheduling layer is based on Airflow and is responsible for the scheduling of all offline tasks.</p><p>A task component layer that enables users to develop data through supported components that include tools such as SparkSQL/, HiveSQ, LMR), StarRocks import, etc., directly interfacing with underlying HDFS, MySQL, and other storage systems.</p><p>The monitoring layer is responsible for all aspects of monitoring and alerting on scheduling resources, computing resources, task execution, etc.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="open-data-sync-capability-scenarios">Open Data Sync Capability Scenarios<a class="hash-link" href="#open-data-sync-capability-scenarios" title="Direct link to heading">​</a></h2><p>Challenges with open capabilities: Need to support multiple business scenarios and meet flexible data pipeline requirements (i.e. extend to support more task components such as hive2clickhourse, clickhourse2mysql, etc.)</p><p>Extending task components based on Airflow: higher maintenance costs for extensions, need to reduce costs and increase efficiency (based on the limited provider&#x27;s Airflow offers, less applicable in terms of usage requirements, Airflow is a Python technology stack, while our team is mainly based on the Java technology stack, so the technology stack difference brings higher iteration costs)</p><p>Self-developed task components: the high cost of platform integration, long development cycle, high cost of the configuration of task components. (Research or implement task components by yourself, different ways of adapting the parameters of the components in the service layer, no uniform way of parameter configuration)</p><p>We wanted to investigate a data integration tool that, firstly, supported a rich set of components, provided out-of-the-box capabilities, was easy to extend, and offered a uniform configuration of parameters and a uniform way of using them to facilitate platform integration and maintenance.</p><ul><li>Selection of data integration tools
<img loading="lazy" src="/assets/images/16714327002726-6bfd742beb9534e7fdbd917db5f53d51.jpg" width="720" height="405">
To address the pain points mentioned above, we actively explored solutions and conducted a selection analysis of several mainstream data integration products in the industry. As you can see from the comparison above, Datax and SeaTunnel both offer good scalability, and high stability, support rich connector plugins, provide scripted, uniformly configurable usage, and have active communities.</li></ul><p>However, Datax is limited by being distributed and is not well suited to massive data scenarios.</p><p>In contrast, SeaTunnel offers the ability to provide distributed execution, distributed transactions, scalable levels of data handling, and the ability to provide a unified technical solution in data synchronization scenarios.</p><p>In addition to the advantages and features described above and the applicable scenarios, more importantly, the current offline computing resources for big data are unified and managed by yarn, and for the subsequently extended tasks we also wish to execute on Yarn, we finally prefer SeaTunnel for our usage scenarios.</p><p>Further performance testing of SeaTunnel and the development of an open data scheduling platform to integrate SeaTunnel may be carried out at a later stage, and its use will be rolled out gradually.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="outbound-scenario-hive-data-sync-to-starrocks">Outbound scenario: Hive data sync to StarRocks<a class="hash-link" href="#outbound-scenario-hive-data-sync-to-starrocks" title="Direct link to heading">​</a></h2><p>To briefly introduce the background, the Big Data platform has now completed the unification of the OLAP engine layer, using the StarRocks engine to replace the previous Kylin engine as the main query engine in OLAP scenarios.</p><p>In the data processing process, after the data is modelled in the data warehouse, the upper model needs to be imported into the OLAP engine for query acceleration, so there are a lot of tasks to push data from Hive to StarRocks every day. task (based on a wrapper for the StarRocks Broker Load import method) to a StarRocks-based table.</p><p>The current pain points are twofold.</p><p>·Long data synchronization links: Hive2StarRocks processing links, which require at least two tasks, are relatively redundant.</p><p>·Outbound efficiency: From the perspective of outbound efficiency, many Hive models themselves are processed by Spark SQL, and based on the processing the Spark Dataset in memory can be pushed directly to StarRocks without dropping the disk, improving the model’s regional time.</p><p><img loading="lazy" src="/assets/images/16714327218590-2644dc4ad1179eab81d40fc774d970e9.jpg" width="720" height="405">
StarRocks currently also supports Spark Load, based on the Spark bulk data import method, but our ETL is more complex, needs to support data conversion multi-table Join, data aggregation operations, etc., so temporarily can not meet.</p><p>We know from the SeaTunnel community that there are plans to support the StarRocks Sink Connector, and we are working on that part as well, so we will continue to communicate with the community to build it together later.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="how-to-get-involved-in-community-building">How to get involved in community building<a class="hash-link" href="#how-to-get-involved-in-community-building" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-community-contribution">SeaTunnel Community Contribution<a class="hash-link" href="#seatunnel-community-contribution" title="Direct link to heading">​</a></h3><p>As mentioned earlier, the community has completed the refactoring of the V1 to V2 API and needs to implement more connector plug-ins based on the V2 version of the connector API, which I was lucky enough to contribute to.</p><p>I am currently responsible for big data infrastructure work, which many mainstream big data components big data also use, so when the community proposed a connector issue, I was also very interested in it.</p><p>As the platform is also investigating SeaTunnel, learning and being able to contribute pr to the community is a great way to learn about SeaTunnel.</p><p>I remember at first I proposed a less difficult pr to implement the WeChat sink connector, but in the process of contributing I encountered many problems, bad coding style, code style did not take into account the rich output format supported by the extension, etc. Although the process was not so smooth, I was really excited and accomplished when the pr was merged. Although the process was not so smooth, it was very exciting and rewarding when the pr was merged.</p><p>As I became more familiar with the process, I became much more efficient at submitting pr and was confident enough to attempt difficult issues.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="how-to-get-involved-in-community-contributions-quickly">How to get involved in community contributions quickly<a class="hash-link" href="#how-to-get-involved-in-community-contributions-quickly" title="Direct link to heading">​</a></h3><ul><li>Good first issue
Good first issue #3018 #2828</li></ul><p>If you are a first-time community contributor, it is advisable to focus on the Good first issue first, as it is basically a relatively simple and newcomer-friendly issue.</p><p>Through Good first issue, you can get familiar with the whole process of participating in the GitHub open source community contribution, for example, first fork the project, then submit the changes, and finally submit the pull request, waiting for the community to review, the community will target to you to put forward some suggestions for improvement, directly will leave a comment below, until when your pr is merged in, this will have completed a comp</p><ul><li>Subscribe to community mailings
Once you’re familiar with the pr contribution process, you can subscribe to community emails to keep up to date with what’s happening in the community, such as what features are currently being worked on and what’s planned for future iterations. If you’re interested in a feature, you can contribute to it in your own situation!</li><li>Familiarity with git use
The main git commands used in development are git clone, git pull, git rebase and git merge. git rebase is recommended in the community development specification and does not generate additional commits compared to git merge.</li><li>Familiarity with GitHub project collaboration process
Open source projects are developed collaboratively by multiple people, and the collaboration method on GitHub is at its core outlined in fork For example, the apache st project, which is under the apache space, is first forked to our own space on GitHub</li></ul><p>Then modify the implementation, mention a pull request, and submit the pull request to be associated with the issue, in the commit, if we change a long time, in the upward commit, then the target branch has a lot of new commits exhausted this time we need to do a pull&amp; merge or rebase.</p><ul><li>Source code compilation project
It is important to be familiar with source compilation, as local source compilation can prove that the code added to a project can be compiled, and can be used as a preliminary check before committing to pr. Source compilation is generally slow and can be speeded up by using mvn -T for multi-threaded parallel compilation.</li><li>Compilation checks
Pre-compilation checks, including Licence header, Code checkstyle, and Document checkstyle, will be checked during Maven compilation, and if they fail, the CI will not be passed. So it is recommended to use some plug-in tools in the idea to improve the efficiency, such as Code checkstyle has a plug-in to automatically check the code specification, Licence header can add code templates in the idea, these have been shared by the community before how to do!</li><li>Add full E2E</li></ul><p>Add full E2E testing and ensure that the E2E is passed before the Pull request.</p><p>Finally, I hope more students will join the SeaTunnel community, where you can not only feel the open-source spirit and culture of Apache but also understand the management process of Apache projects and learn good code design ideas.</p><p>We hope that by working together and growing together, we can build SeaTunnel into a top-notch data integration platform.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/2022/09/20/A-tutorial-to-help-you develop-a-SeaTunnel-Connector-hand-by-hand-while-avoiding -pitfalls">A tutorial to help you develop a SeaTunnel Connector hand-by-hand while avoiding pitfalls</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-09-20T00:00:00.000Z" itemprop="datePublished">September 20, 2022</time> · <!-- -->13 min read</div></header><div class="markdown" itemprop="articleBody"><p><img src="https://miro.medium.com/max/1400/0*4fOZaPYhwL2pdUpK"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-connector-acess-plan">SeaTunnel Connector Acess Plan<a class="hash-link" href="#seatunnel-connector-acess-plan" title="Direct link to heading">​</a></h2><p>During the recent live event of the SeaTunnel Connector Access Plan, Beluga open source engineer Wang Hailin shared the “SeaTunnel Connector Access Plan and Development Guide to Avoiding Pit,” and taught everyone how to develop a connector from scratch, including the whole process — from preparation to testing, and final PR.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="speaker">Speaker<a class="hash-link" href="#speaker" title="Direct link to heading">​</a></h2><p><img src="https://miro.medium.com/max/1100/0*LRtFiJkgV5DEWOAa">
<strong>Wang Hailin</strong></p><p>Wailin Hailin is an open-source enthusiast, SkyWalking Committer, DolphinScheduler, and SeaTunnel contributor. His current work focuses on performance monitoring, data processing, and more. He likes to study related technical implementations and participate in community exchanges and contributions.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="this-presentation-is-divided-into-5-parts">This presentation is divided into 5 parts:<a class="hash-link" href="#this-presentation-is-divided-into-5-parts" title="Direct link to heading">​</a></h2><ol><li>About the connector access incentive program</li><li>Preparation before claiming/developing connector</li><li>Small things in development</li><li>Considerations for writing E2E Tests</li><li>Preparations to submit a PR</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="1-about-the-connector-access-incentive-plan">1. About the Connector Access Incentive Plan<a class="hash-link" href="#1-about-the-connector-access-incentive-plan" title="Direct link to heading">​</a></h2><p>Firstly, let me introduce the SeaTunnel Connector Access Incentive Program, and the steps to develop a connector from start to finish (even for novices). This includes the whole process of preparation for development, testing, and final PR.</p><p>The SeaTunnel community released a new connector API not long ago, which supports running on various engines, including Flink, Spark, and more. This eliminates the need for repeated development of the old version.</p><p>After the new API is released, the old connector needs to be migrated, or the new connector should be supported.</p><p>In order to motivate the community to actively participate in the SeaTunnel Connector Access work and help build SeaTunnel into a more efficient data integration platform, the SeaTunnel community-initiated activities, sponsored by Beluga Open Source.</p><p>The activities have three modes: simple, medium, and hard for the task of accessing the connector. The threshold is low.</p><p>You can see which tasks need to be claimed on the activity issue list, as well as segmentation based on difficulty and priority. You can choose the activity you are comfortable with. You can start contributing based on the difficulty level.
<img src="https://miro.medium.com/max/1400/0*laqub6yhNDOqPaGc"></p><p>The ecological construction of SeaTunnel can become more complete and advanced only with the help of your contributions. You are welcome to participate actively.</p><p>In order to express our gratitude, our event has set up a link where points can be exchanged for physical prizes. The more points you get, the more prized you can win!</p><p>Presently, we’ve seen many small partners participate in the event and submit their connectors. It’s not too late to join as there is still a significant period of time before the event ends. Based on the difficulty of the activity, the deadline may be relaxed or extended.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="2-preparations-before-claimingdeveloping-connectors">2. Preparations Before Claiming/Developing Connectors<a class="hash-link" href="#2-preparations-before-claimingdeveloping-connectors" title="Direct link to heading">​</a></h2><p>So, how do you get involved with this amazing activity?</p><p>By first getting to know the basics of a connector.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="01-what-is-a-connector">01. What is a connector?<a class="hash-link" href="#01-what-is-a-connector" title="Direct link to heading">​</a></h3><p><img src="https://miro.medium.com/max/750/0*IjdxVOKUu649s7vQ">
A connector is composed of Source and SInk (Source + Sink).</p><p>In the above figure, the connectors are connected to various data sources at the upper and lower layers. The source is responsible for reading data from external data sources, while the sink is responsible for writing data to external sources.</p><p>There is also an abstraction layer between the source and the sink.</p><p>Through this abstraction later, the data types of various data sources can be uniformly converted into the data format of SeaTunnelRow. This allows users to arbitrarily assemble various sources and sinks, so as to realize the integration of heterogeneous data sources, and data synchronization between multiple data sources.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="02-how-to-claim-a-connector">02. How to claim a connector<a class="hash-link" href="#02-how-to-claim-a-connector" title="Direct link to heading">​</a></h3><p>After understanding the basic concepts, the next step is to claim the connector.</p><p>GitHub link: <a href="https://github.com/apache/incubator-seatunnel/issues/1946" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/1946</a></p><p>You can use the above-mentioned GitHub link to see our plans for connecting to the connector. You can make any additions at any time.</p><p>First, find a connector that has not been claimed. To avoid conflicts, search the entire issue to see if anyone has submitted a PR.</p><p>After claiming the connector, we suggest that you create an issue of the corresponding feature, synchronize the problems you encountered in the development, and discuss the design of your solution.</p><p>If you encounter any problems and need help, you can describe them in the issue, and the community can take it up together. Participate in the discussions to help solve the problem. This is also added to the record of the function implementation process, which makes it easy to refer to when maintaining and modifying in the future.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="03-compile-the-project">03. Compile the project<a class="hash-link" href="#03-compile-the-project" title="Direct link to heading">​</a></h3><p>After claiming the connector, it’s time to prepare the development environment.</p><p>First, fork the SeaTunnel project to the local development environment and compile it.</p><p>Here’s the compilation reference documentation: <a href="https://github.com/apache/incubator-seatunnel/blob/dev/docs/en/contribution/setup.md" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/blob/dev/docs/en/contribution/setup.md</a></p><p>Run the testcase in the documentation after the compilation is successful. You might encounter some issues/problems during the first contact compilation process, such as the following compilation errors:</p><p><img src="https://miro.medium.com/max/1400/0*rGkqQzdfwd6Dp-mR">
<img src="https://miro.medium.com/max/1400/0*r2X63dr2YBTxZGen"></p><p><strong>The solution to the above exceptions:</strong></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">rm {your_maven_dir}/repository/org/apache/seatunnel</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">./mvnw clean</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Recompile it</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="04-understand-connector-related-code-structure">04. Understand Connector related code structure<a class="hash-link" href="#04-understand-connector-related-code-structure" title="Direct link to heading">​</a></h3><p>The success of project compilation means that the development environment is ready. Next, let’s take a look at the project code structure and API interface structure of the connector.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="engineering-code-structure">Engineering Code structure<a class="hash-link" href="#engineering-code-structure" title="Direct link to heading">​</a></h4><p>After the project is compiled, there are three parts related to the connector. The first part is the code implementation and dependency management of the new connector module.</p><ul><li>seatunnel-connectors-v2 stores the connector submodule</li><li>seatunnel-connectors-v2-dist manages connectors-v2 maven dependencies</li></ul><p>The second part is the example. When testing locally, you can build a corresponding case on the example to test the connector.</p><ul><li>seatunnel-flink-connector-v2-example example running on Flink</li><li>seatunnel-spark-connector-v2-example example running on Spark</li></ul><p>The third part is the E2E-testcase: adding targeted test cases on the respective running engines of Spark or Flink, and verifying the functional logic of the connector through automated testing.</p><ul><li>seatunnel-flink-connector-v2-e2e testcase running on Flink</li><li>seatunnel-spark-connector-v2-e2e testcase running on Spark</li></ul><p><strong>Code structure (interfaces, base classes)</strong></p><p>The public interfaces and base classes used in the development are fully described in our readme. For example, API function usage scenarios.</p><p>Here’s the link: <a href="https://github.com/apache/incubator-seatunnel/blob/dev/seatunnel-connectors-v2/README.en.md" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/blob/dev/seatunnel-connectors-v2/README.en.md</a></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="05-see-how-other-people-develop-connectors">05. See how other people develop connectors<a class="hash-link" href="#05-see-how-other-people-develop-connectors" title="Direct link to heading">​</a></h3><p>After going through the above steps, don’t rush to start the work. Instead, first, check out how others do it.</p><p>We strongly recommend you check out the connector novice development tutorial shared on the community&#x27;s official account:</p><ul><li>[SeaTunnel Connector Minimalist Development Process]</li><li>[New API Connector Development Analysis]</li><li>[The way of decoupling Apache SeaTunnel (Incubating) and the computing engine — what we’ve done to reconstruct the API]</li></ul><p>In addition, you can refer to the merged Connector code to see the scope of changes, the public interfaces and dependencies used, and the test cases.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="3-small-issuestasks-during-development">3. Small Issues/Tasks During Development<a class="hash-link" href="#3-small-issuestasks-during-development" title="Direct link to heading">​</a></h2><p>Next, you have to officially enter the connector development process. What problems may be encountered during the development process?</p><p>The connector is divided into the source and sink ends — you can choose either one or both.</p><p><img src="https://miro.medium.com/max/640/0*QxOnCYLu4AcvKw58"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="01-source-related-development">01. Source-related development<a class="hash-link" href="#01-source-related-development" title="Direct link to heading">​</a></h3><p>The first thing to pay attention to when developing a source is to determine the reading mode of the source: is it streaming or batch? Is support still required?</p><p>Use the Source#getBoundedness interface to mark the modes supported by the source.</p><p>For example, Kafka naturally supports streaming reading, but it can also support batch mode reading by obtaining lastOffset in the source.</p><p>Another question to be aware of: does the source require concurrent reads? If it is single concurrency, after the source is started, a reader will be created to read the data from the data source.</p><p>If you want to achieve multi-concurrency, you need to implement an enumerator interface through which data blocks are allocated to readers, and the readers each read their allocated data blocks.</p><p>For example, the Kafka source uses partition sharding, and the jdbc source uses fields for range query sharding. It should be noted here that if it is a concurrent reading method, the stability of the data block distribution rules must be ensured.</p><p>This is because currently, the connector has a corresponding enumerator on each shard in actual operation, and it is necessary to ensure that the enumerator has data in each shard.</p><p>Thirdly, does the source need to support resumable transfer/state restoration?</p><p>If you want to support this, you need to implement:</p><ul><li><strong>Source#restoreEnumerator</strong>: restore state</li><li><strong>Enumerator#snapshotState</strong>: storage shard allocation</li><li><strong>Reader#snapshotState</strong>: stores the read position</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="02-sink-related-development">02. Sink-related development<a class="hash-link" href="#02-sink-related-development" title="Direct link to heading">​</a></h3><p>If the sink is a common sink implementation, use Sink#createWriter to write our data according to the concurrency of the source.</p><p>If you need to support failure recovery, you need to implement:</p><ul><li><strong>Sink#restoreWriter</strong>: restore state</li><li><strong>Writer#snapshotState</strong>: snapshot state</li></ul><p>If you want to support a two-phase commit, you need to implement the following interfaces:</p><ul><li>Sink#createCommitter</li><li>Writer#prepareCommit: pre-commit</li><li>Committer#commit: abort Phase 2 commit</li></ul><p><img src="https://miro.medium.com/max/640/0*GpYdUR2mTlur8jHQ"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="03-connector-related">03. Connector related<a class="hash-link" href="#03-connector-related" title="Direct link to heading">​</a></h3><p>Next, let’s take a look at some of the general problems, especially when the first contribution is made with different styles for each environment, there are often various problems. Therefore, it is recommended that you import tools/checkstyle/checkStyle.xml from the project during development, and use a unified coding format.</p><p>Whether it is a source or a sink, it will involve defining the data format. The community is pushing for a unified data format definition.</p><p>To define Schema, please refer to PR: <a href="https://github.com/apache/incubator-seatunnel/pull/2392" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2392</a>
To define the Format, please refer to PR: <a href="https://github.com/apache/incubator-seatunnel/pull/2435" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2435</a></p><p>If you feel that the compilation speed is slow, you can temporarily annotate the old version of the connector-related module in order to speed up both development and debugging.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="04-how-to-seek-help">04. How to seek help<a class="hash-link" href="#04-how-to-seek-help" title="Direct link to heading">​</a></h3><p>When you encounter problems during development and need help, you can:</p><ul><li>Describe the problem in your Issue and call active contributors</li><li>Discuss on mailing lists and Slack</li><li>Communicate through the WeChat group (if you have not joined, please follow the SeaTunnel official account to join the group, and add a small assistant WeChat seatunnel1)</li><li>There may be a community docking group for docking third-party components (allowing you to do more with less)</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="4-notes-on-writing-e2e-tests">4. Notes on Writing E2E Tests<a class="hash-link" href="#4-notes-on-writing-e2e-tests" title="Direct link to heading">​</a></h2><p>E2E testing is very important. It is often called the gatekeeper of connector quality.</p><p>This is because, if the connector you wrote is not tested, it could be difficult for the community to judge whether there are problems with the implementation of the static code.</p><p>Therefore, E2E testing is not only functional verification but also a process of checking data logic, which can reduce the pressure on the community to review code and ensure basic functional correctness.</p><p>In E2E testing, these are some of the problems that may be encountered:</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="01-e2e-failed--test-case-network-address-conflict">01. E2E Failed — Test Case Network Address Conflict<a class="hash-link" href="#01-e2e-failed--test-case-network-address-conflict" title="Direct link to heading">​</a></h3><p><strong>Because the E2E network deployment structure has the following characteristics:</strong></p><ul><li>External components that Spark, Flink, and e2e-test case depend on (for example, MySQL), use the container networkAliases(host) as the access address</li><li>e2e-test case on both sides of Spark and Flink may run in parallel under the same host</li><li>External components that e2e-test case depends on, need to map ports to hosts for e2e-test case to access</li></ul><p><strong>Therefore, E2E has to pay attention to:</strong></p><ul><li>The external components e2e-test case depends on the ports mapped to the external networkAliases, and so cannot be the same in the test cases on both sides of Spark and Flink</li><li>e2e-test case uses localhost, the above-mapped port, to access external components</li><li>e2e’s configuration file uses networkAliases(host), the external components that depend on port access in the container</li></ul><p>Here’s the E2E Testcase reference PR: <a href="https://github.com/apache/incubator-seatunnel/pull/2429" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2429</a></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="02-e2e-failure--spark-jar-package-conflict">02. E2E failure — Spark jar package conflict<a class="hash-link" href="#02-e2e-failure--spark-jar-package-conflict" title="Direct link to heading">​</a></h3><p>Spark uses the parent first-class loader by default, which may conflict with the package referenced by the connector. For this, the userClassPathFirst classloader can be configured in the Connector environment.</p><p>However, the current packaging structure of SeaTunnel will cause userClassPathFirst to not work properly, so we created an issue, <a href="https://github.com/apache/incubator-seatunnel/pull/2474" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2474</a>, to track this issue. Everyone is welcome to contribute solutions.</p><p>Currently, this can only be resolved by replacing conflicting packages in the spark jars directory with the documentation.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="03-e2e-failure--connector-jar-package-conflict">03. E2E failure — Connector jar package conflict<a class="hash-link" href="#03-e2e-failure--connector-jar-package-conflict" title="Direct link to heading">​</a></h3><p>Both the old and new versions of Connector are dependent on the E2E project and cause conflicts.</p><p>PR <a href="https://github.com/apache/incubator-seatunnel/pull/2414" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2414</a> has resolved this issue.</p><p><strong>Version conflict between Connector-v2:</strong></p><ul><li>Mainly occurs during E2E, because the E2E project depends on all Connectors</li><li>We may plan to provide a separate test project for each Connector (or version) in the future</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="04-insufficient-e2e--sink-logic-verification">04. Insufficient E2E — Sink Logic Verification<a class="hash-link" href="#04-insufficient-e2e--sink-logic-verification" title="Direct link to heading">​</a></h3><p>The FakeSource of the Connector-v2 version can only generate random data of a few fixed columns at present, and the community partners are optimizing it to make it better. <a href="https://github.com/apache/incubator-seatunnel/pull/2406" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2406
</a>
That said, we can temporarily solve this problem by simulating the data of the specified content through Transform sql:
<img src="https://miro.medium.com/max/1400/0*_uvD-JWrVbABolAq"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="05-insufficient-e2e--source-validation-data">05. Insufficient E2E — Source validation data<a class="hash-link" href="#05-insufficient-e2e--source-validation-data" title="Direct link to heading">​</a></h3><p>The Assert Sink can configure column rules, but cannot do row-level value checking. For this problem, you can temporarily use other connector sinks with external storage for query verification data.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="06-e2e-stability-improvement">06. E2E stability improvement<a class="hash-link" href="#06-e2e-stability-improvement" title="Direct link to heading">​</a></h3><p>In many cases, when E2E starts, you might use Thread.sleep to wait for resource initialization. Here, sleep will cause fewer initialization failures but more time-wasting issues.</p><p>In addition, due to the instability of resources, network, and other issues, you might be able to run it now but not later.
<img src="https://miro.medium.com/max/1400/0*iBxwGDaHfXROqtEt">
<img src="https://miro.medium.com/max/1400/0*c2yFYbeVWPvHV7SY">
To avoid this problem, Thread.sleep can be replaced with Awaitility.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="07-a-method-to-speed-up-e2e">07. A method to speed up E2E<a class="hash-link" href="#07-a-method-to-speed-up-e2e" title="Direct link to heading">​</a></h3><p>At present, I see that most people run E2E tests separately for both source and sink. If you want to speed up the PR process, it is recommended that you combine both the sink and source into one E2E testcase for verification, and run the testcase only once.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="5-checks-before-submitting-a-pr">5. Checks Before Submitting a PR<a class="hash-link" href="#5-checks-before-submitting-a-pr" title="Direct link to heading">​</a></h2><p>After completing the previous steps, please make sure you do some checks before submitting PR — including the following aspects:</p><p>Complete recompile project:</p><ul><li>Codestyle validation, dependency validation</li><li>The successful compilation before does not mean that it can be compiled successfully now</li></ul><p>Running E2E locally succeeds:</p><ul><li>Both Flink and Spark are verified</li></ul><p>Supplement or change the document and review it again before submitting:</p><ul><li>Review for places not covered by tests</li><li>Places that hav been reviewed before and needs to be checked again</li><li>Review for including all files, not just code</li></ul><p>The above operations and steps can greatly save CI resources, speed up PR Merged, and reduce the costs of community reviews.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/2022/09/19/Code-Demo-for-SeaTunnel-Connector-Development-Process">Code Demo for SeaTunnel Connector Development Process</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-09-19T00:00:00.000Z" itemprop="datePublished">September 19, 2022</time> · <!-- -->10 min read</div></header><div class="markdown" itemprop="articleBody"><p>At the Apache SeaTunnel&amp;Apache Doris Joint Meetup held on July 24, Liu Li — senior engineer of WhaleOps and contributor to Apache SeaTunnel — mentioned an easy way to develop a connector in SeaTunnel quickly.</p><p><img src="https://miro.medium.com/max/700/1*Rbd5BrSuGiZUQA53DXZrBw.png">
We’ll divide it into four key parts:</p><p>● The definition of a Connector</p><p>● How to access data sources and targets</p><p>● Code to demonstrate how to implement a Connector</p><p>● Sources and targets that are currently supported</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="definition-of-a-connector">Definition of a Connector<a class="hash-link" href="#definition-of-a-connector" title="Direct link to heading">​</a></h2><p>The Connector consists of Source and Sink and is a concrete implementation of accessing data sources.</p><p>Source: The Source is responsible for reading data from sources such as MySQLSource, DorisSource, HDFSSource, TXTSource, and more.</p><p>Sink: The Sink is responsible for writing read data to the target, including MySQLSink, ClickHouseSink, HudiSink, and more. Data transfer, and more specifically, data synchronization is completed through the cooperation between the Source and Sink.</p><p><img src="https://miro.medium.com/max/298/1*hsfa9Xtzt7o028XjCpqoOg.png"></p><p>Of course, different sources and sinks can cooperate with each other.</p><p>For example, you can use MySQL Source, and Doris Sink to synchronize data from MySQL to Doris, or even read data from MySQL Source and write to HDFS Sink.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="how-to-access-data-sources-and-targets">How to access data sources and targets<a class="hash-link" href="#how-to-access-data-sources-and-targets" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="how-to-access-source">How to access Source<a class="hash-link" href="#how-to-access-source" title="Direct link to heading">​</a></h3><p>Firstly, let’s take a look at how we can access the Source. To elaborate, let’s dive in and check out how we can implement a source and the core interfaces that need to be implemented to access the Source.</p><p>The simplest Source is a single concurrent Source. However, if a source does not support state storage and other advanced functions, what interfaces should we implement in these simple single concurrent sources?</p><p>Firstly, we need to use getBoundedness in the Source to identify whether the Source supports real-time or offline, or both.</p><p>createReader creates a Reader whose main function is to read the specific implementation of data. A single concurrent source is really simple as we only need to implement one method, pollNext, through which the read data is sent.</p><p>If concurrent reading is required, what additional interfaces should we implement?
<img src="https://miro.medium.com/max/393/1*bRxRjyMOGkVqseQkg0ONWg.png"></p><p>For concurrent reading, we’ll introduce a new member, called the Enumerator.</p><p>We implement createEnumerator in Source, and the main function of this member is to create an Enumerator to split the task into segments and then send it to the Reader.</p><p>For example, a task can be divided into 4 splits.</p><p>If it is concurrent twice, it’ll correspond to two Readers. Two of the four splits will be sent to Reader1, and the other two will be sent to Reader2.</p><p>If the number of concurrencies is more — for example, let’s say there are four concurrences, then you have to create four Readers. You have to use the corresponding four splits for concurrent reading for improved efficiency.</p><p>A corresponding interface in the Enumerator called the addSplitsBack sends the splits to the corresponding Reader. Through this method, the ID of the Reader can be specified.</p><p>Similarly, there is an interface called the addSplits in the Reader to receive the splits sent by the Enumerator for data reading.</p><p>In a nutshell, for concurrent reading, we need an Enumerator to implement task splitting and send the splits to the reader. Also, the reader receives the splits and uses them for reading.</p><p>In addition, if we need to support resuming and exactly-once semantics, what additional interfaces should we implement?</p><p>If the goal is to resume the transfer from a breakpoint, we must save the state and restore it. For this, we need to implement a restoreEnumerator in Source.</p><p>The restoreEnumerator method is used to restore an Enumerator through the state and restore the split.</p><p>Correspondingly, we need to implement a snapshotState in this enumerator, which is used to save the state of the current Enumerator and perform failure recovery during checkpoints.</p><p>At the same time, the Reader will also have a snapshotState method to save the split state of the Reader.</p><p>In the event of a failed restart, the Enumerator can be restored through the saved state. After the split is restored, reading can be continued from the place of failure, including fetching and incoming data.</p><p>The exact one-time semantics actually requires the source to support data replays, such as Kafka, Pulsar, and others. In addition, the sink must be submitted in two phases, i.e., the precise one-time semantics can be achieved with the cooperation of these two sources and sinks.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="how-to-access-sink">How to access Sink<a class="hash-link" href="#how-to-access-sink" title="Direct link to heading">​</a></h3><p>Now, let’s take a look at how to connect to the Sink. What interfaces does the Sink need to implement?</p><p>Truth be told, Sink is relatively simple. For concurrent sinks, when state storage and two-phase commit are not supported, the Sink is simple.</p><p>To elaborate, the Sink does not distinguish between stream synchronization and batch synchronization as the Sink — and the entire SeaTunnel API system — supports <strong>Unified Stream and Batch Processing.</strong></p><p>Firstly, we need to implement createWriter. A Writer is used for data writing.</p><p>You need to implement a writer method in Writer through which data is written to the target library.</p><p><img src="https://miro.medium.com/max/414/1*xQ7DRHdBGv-ofjSYdSHAoA.png"></p><p>As shown in the figure above, if two concurrencies are set, the engine will call the createWriter method twice in order to generate two Writers. The engine will feed data to these two writers, which will write the data to the target through the write method.</p><p>For a more advanced setup, for example, we need to support <strong>two-phase commit and state storage</strong>.</p><p>Here, what additional interfaces should we implement?</p><p>First, let’s introduce a new member, the Committer, whose main role is for the second-stage commit.</p><p><img src="https://miro.medium.com/max/414/1*cvj1i2A-E-1c_bCZneshtg.png"></p><p>Since Sink is stored in state, it is necessary to restore Writer through the state. Hence, restoreWriter should be implemented.</p><p>Also, since we have introduced a new member, the Committer, we should also implement a createCommitter in the sink. We can then use this method to create a Committer for the second-stage commit or rollback.</p><p>In this case, what additional interfaces does Writer need to implement?</p><p>Since it is a two-phase commit, the first-phase commit is done in the Writer through the implementation of the prepareCommit method — which is mainly used for the first-phase commit.</p><p>In addition, state storage and failure recovery is also supported, meaning we need snapshotState to take snapshots at checkpoints. This saves the state for failure recovery scenarios.</p><p>The Committer is the core here. It is mainly used for rollback and commit operations in the second phase.</p><p>For the corresponding process, we need to write data to the database. Here, the engine will trigger the first stage commit during the checkpoint, and then the Writer needs to prepare a commit.</p><p>At the same time, it will return commitInfo to the engine, and the engine will judge whether the first stage commits of all writers are successful.</p><p>If they are indeed successful, the engine will use the commit method to actually commit.</p><p>For MySQL, the first-stage commit just saves a transaction ID and sends it to the commit. The engine determines whether the transaction ID is committed or rolled back.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="how-to-implement-the-connector">How to implement the Connector<a class="hash-link" href="#how-to-implement-the-connector" title="Direct link to heading">​</a></h2><p>We’ve taken a look at Source and Sink; let’s now look at how to access the data source and implement your own Connector.</p><p>Firstly, we need to build a development environment for the Connector.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-necessary-environment">The necessary environment<a class="hash-link" href="#the-necessary-environment" title="Direct link to heading">​</a></h3><ol><li><p>Java 1.8\11, Maven, IntelliJ IDEA</p></li><li><p>Windows users need to additionally download gitbash (<a href="https://gitforwindows.org/" target="_blank" rel="noopener noreferrer">https://gitforwindows.org/</a>)</p></li><li><p>Once you have these, you can download the SeaTunnel source code by cloning the git.</p></li><li><p>Download SeaTunnel source code 1, git clone <a href="https://github.com/apache/incubator-seatunnel.git2" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel.git2</a>, cd incubator-seatunnel</p></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-engineering-structure">SeaTunnel Engineering Structure<a class="hash-link" href="#seatunnel-engineering-structure" title="Direct link to heading">​</a></h3><p>We then open it again through the IDE, and see the directory structure as shown in the figure:</p><p><img src="https://miro.medium.com/max/700/1*utRhNAsYiqQqBFa4Tjewgw.png"></p><p>The directory is divided into several parts:</p><ol><li>Connector — v2</li></ol><p>Specific implementation of the new Connector(Connector — v2) will be placed in this module.</p><ol start="2"><li>connector-v2-dist</li></ol><p>The translation layer of the new connector translates into specific engine implementation — instead of implementing under corresponding engines such as Spark, Flink, and ST-Engine. ST-Engine is the “important, big project” the community is striving to implement. This project is worth the wait.</p><ol start="3"><li>examples</li></ol><p>This package provides a single-machine local operation method, which is convenient for debugging while implementing the Connector.</p><ol start="4"><li>e2e</li></ol><p>The e2e package is for e2e testing of the Connector.</p><p>Next, let’s check out how a Connector can be created (based on the new Connector). Here is the step-by-step process:</p><ol><li><p>Create a new module in the seatunnel-connectors-v2 directory and name it this way: connector-{connector name}.</p></li><li><p>The pom file can refer to the pom file of the existing connector and add the current child model to the parent model’s pom file.</p></li><li><p>Create two new packages corresponding to the packages of Source and Sink, respectively:</p></li></ol><p>a. org.apache.seatunnel.connectors.seatunnel.{connector name}.source</p><p>b. org.apache.seatunnel.connectors.seatunnel.{connector name}.sink</p><p>Take this mysocket example shown in the figure:</p><p><img src="https://miro.medium.com/max/700/1*K1btD2gNwYxj96OJnPfW2Q.png"></p><p>To do some implementation, develop the connector. During implementation, you can use the example module for local debugging if you need to debug. That said, this module mainly provides the local running environment of Flink and Spark.</p><p><img src="https://miro.medium.com/max/700/1*qOc3q7okzo7jObHxloc7WQ.png"></p><p>As you can see in the image, there are numerous examples under the “Example” module — including seatunnel-flink-connector-v2-example.</p><p>So how do you use them?</p><p>Let’s take an example. The debugging steps on Flink are as follows (these actions are under the seatunnel-flink-connector-v2-example module:</p><ol><li><p>Add connector dependencies in pom.xml</p></li><li><p>Add the task configuration file under resources/examples</p></li><li><p>Configure the file in the SeaTunnelApiExample main method</p></li><li><p>Run the main method</p></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="code-demo">Code Demo<a class="hash-link" href="#code-demo" title="Direct link to heading">​</a></h3><p>This code demonstration is based on DingTalk.</p><p>Here’s a reference（ 19:35s–37:10s）:</p><p><a href="https://weixin.qq.com/sph/A1ri7B" target="_blank" rel="noopener noreferrer">https://weixin.qq.com/sph/A1ri7B</a></p><p><img src="https://miro.medium.com/max/700/1*ej9ronizPtC09ILWJDlbUg.png"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="new-connectors-supported-at-this-stage">New Connectors supported at this stage<a class="hash-link" href="#new-connectors-supported-at-this-stage" title="Direct link to heading">​</a></h3><p>As of July 14, contributions and statistics for the completed connectors are welcome. You are more than welcome to try them out, and raise issues in our community if you find bugs.</p><p><img src="https://miro.medium.com/max/700/1*RHNJDcbvKmSt2UGGSz3Icg.png"></p><p>The Connector shared below have already been claimed and developed:</p><p><img src="https://miro.medium.com/max/700/1*RHNJDcbvKmSt2UGGSz3Icg.png"></p><p>Also, we have Connectors in the roadmap — the connectors we want to support in the near future. To foster the process, the SeaTunnel Community initiated SeaTunnel Connector Access Incentive Plan, you are more than welcome to contribute to the project.</p><p>SeaTunnel Connector Access Incentive Plan: <a href="https://github.com/apache/incubator-seatunnel/issues/1946" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/1946</a></p><p>You can claim tasks that haven’t been marked in the comment area, and take a spree home! Here is part of the connectors that need to be accessed as soon as possible:
<img src="https://miro.medium.com/max/414/1*n-ixPtq066Acx4Ja5qNQqw.png">
In fact, the implementations of Connectors like Feishu, DingTalk, and Facebook messenger are quite simple as the connectors do not need to carry a large amount of data (just a simple Source and Sink). This is in sharp contrast to Hive and other databases that need to consider transaction consistency or concurrency issues.</p><p>We welcome everyone to make contributions and join our Apache SeaTunnel family!</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="about-seatunnel">About SeaTunnel<a class="hash-link" href="#about-seatunnel" title="Direct link to heading">​</a></h2><p>SeaTunnel (formerly Waterdrop) is an easy-to-use, ultra-high-performance distributed data integration platform that supports the real-time synchronization of massive amounts of data and can synchronize hundreds of billions of data per day stably and efficiently.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="why-do-we-need-seatunnel">Why do we need SeaTunnel?<a class="hash-link" href="#why-do-we-need-seatunnel" title="Direct link to heading">​</a></h3><p>SeaTunnel does everything it can to solve the problems you may encounter in synchronizing massive amounts of data.</p><ul><li>Data loss and duplication</li><li>Task buildup and latency</li><li>Low throughput</li><li>Long application-to-production cycle time</li><li>Lack of application status monitoring</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="seatunnel-usage-scenarios">SeaTunnel Usage Scenarios<a class="hash-link" href="#seatunnel-usage-scenarios" title="Direct link to heading">​</a></h3><ul><li>Massive data synchronization</li><li>Massive data integration</li><li>ETL of large volumes of data</li><li>Massive data aggregation</li><li>Multi-source data processing</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="features-of-seatunnel">Features of SeaTunnel<a class="hash-link" href="#features-of-seatunnel" title="Direct link to heading">​</a></h3><ul><li>Rich components</li><li>High scalability</li><li>Easy to use</li><li>Mature and stable</li></ul></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/2022/09/14/Talk-With-Overseas-contributors-Why-do-I-contribute-to-SeaTunnel">Talk With Overseas contributors | Why do I contribute to SeaTunnel?</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-09-14T00:00:00.000Z" itemprop="datePublished">September 14, 2022</time> · <!-- -->2 min read</div></header><div class="markdown" itemprop="articleBody"><p>As SeaTunnel gets popular around the world, it is attracting more and more contributors from overseas to join the open-source career. Among them, a big data platform engineer at Kakao enterprise corp., Namgung Chan has recently contributed the Neo4j Sink Connector for the SeaTunnel. We have a talk with him to know why SeaTunnel is attractive to him, and how he thinks SeaTunnel should gain popularity in the South Korean market.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="personal-profile">Personal Profile<a class="hash-link" href="#personal-profile" title="Direct link to heading">​</a></h2><p><img src="https://miro.medium.com/max/1400/1*sKzXjqu6M_VmoperNBYUGQ.jpeg"></p><p>Namgung Chan, South Korea, Big Data Platform Engineer at Kakao enterprise corp.</p><p>Blog (written in Korean): <a href="https://getchan.github.io/" target="_blank" rel="noopener noreferrer">https://getchan.github.io/</a>
GitHub ID: <a href="https://github.com/getChan" target="_blank" rel="noopener noreferrer">https://github.com/getChan</a>
LinkedIn : <a href="https://www.linkedin.com/in/namgung-chan-6a06441b6/" target="_blank" rel="noopener noreferrer">https://www.linkedin.com/in/namgung-chan-6a06441b6/</a></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="contributions-to-the-community">Contributions to the community<a class="hash-link" href="#contributions-to-the-community" title="Direct link to heading">​</a></h3><p>He writes the Neo4j Sink Connector code for the new SeaTunnel Connector API.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="how-to-know-seatunnel-for-the-first-time">How to know SeaTunnel for the first time?<a class="hash-link" href="#how-to-know-seatunnel-for-the-first-time" title="Direct link to heading">​</a></h3><p>It’s the first time Namgung Chan to engage in open source. He wants to learn technical skills by contributing, at the same time experience the open-source culture.</p><p>For him, an open source project which is written by java lang, and made for data engineering, has many issues of ‘help wanted’ or ‘good first issue’ is quite suitable. Then he found SeaTunnel on the Apache Software Foundation project webpage.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-first-impression-of-seatunnel-community">The first impression of SeaTunnel Community<a class="hash-link" href="#the-first-impression-of-seatunnel-community" title="Direct link to heading">​</a></h3><p>Though it was his first open source experience, he felt it was comfortable and interesting to go to the community. He also felt very welcome, because there are many ‘good first issue, and ‘volunteer wanted’ tagged issues and will get a quick response of code review.</p><p>With gaining knowledge of Neo4j, he grows much more confident in open source contribution.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="research-and-comparison">Research and comparison<a class="hash-link" href="#research-and-comparison" title="Direct link to heading">​</a></h3><p>Before knowing about SeaTunnel, Namgung Chan used Spring Cloud Data Flow for data integration. While after experiencing SeaTunnel, he thinks the latter is more lightweight than SCDF, because in SCDF, every source, processor, and sink component are individual applications, but SeaTunnel is not.</p><p>Though hasn’t used SeaTunnel in his working environment yet, Namgung Chan said he would like to use it positively when he is in need, especially for data integration for various data storage.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="expectations-for-seatunnel">Expectations for SeaTunnel<a class="hash-link" href="#expectations-for-seatunnel" title="Direct link to heading">​</a></h3><p>The most exciting new features or optimizations for Namgung Chan are:</p><p>Data Integration for various data storage.
Strict data validation. monitoring extension
Low computing resource
exactly-once data processing
In the future, Namgung Chan plans to keep contributing from light issues to heavy ones, and we hope he will have a good time here!</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/2022/09/12/SeaTunnel-2.1.3-released">SeaTunnel 2.1.3 released! Introducing in Assert Sink connector and NullRate, Nulltf Transform</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-09-12T00:00:00.000Z" itemprop="datePublished">September 12, 2022</time> · <!-- -->3 min read</div></header><div class="markdown" itemprop="articleBody"><p><img src="https://miro.medium.com/max/1400/1*7jtTFNpvwC6nquA-BLfqGg.png"></p><p>More than a month after the release of Apache SeaTunnel(Incubating) 2.1.2, we have been collecting user and developer feedback to bring you version 2.1.3. The new version introduces the Assert Sink connector, which is an inurgent need in the community, and two Transforms, NullRate and Nulltf. Some usability problems in the previous version have also been fixed, improving stability and efficiency.</p><p>This article will introduce the details of the update of Apache SeaTunnel(Incubating) <strong>version 2.1.3</strong>.</p><ul><li>Release Note: <a href="https://github.com/apache/incubator-seatunnel/blob/2.1.3/release-note.md" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/blob/2.1.3/release-note.md</a></li><li>Download address: <a href="https://seatunnel.apache.org/download" target="_blank" rel="noopener noreferrer">https://seatunnel.apache.org/download</a></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="major-feature-updates">Major feature updates<a class="hash-link" href="#major-feature-updates" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="introduces-assert-sink-connector">Introduces Assert Sink connector<a class="hash-link" href="#introduces-assert-sink-connector" title="Direct link to heading">​</a></h3><p>Assert Sink connector is introduced in SeaTunnel version 2.1.3to verify data correctness. Special thanks to Lhyundeadsoul for his contribution.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="add-two-transforms">Add two Transforms<a class="hash-link" href="#add-two-transforms" title="Direct link to heading">​</a></h3><p>In addition, the 2.1.3 version also adds two Transforms, NullRate and Nulltf, which are used to detect data quality and convert null values ​​in the data to generate default values. These two Transforms can effectively improve the availability of data and reduce the frequency of abnormal situations. Special thanks to wsyhj and Interest1-wyt for their contributions.</p><p>At present, SeaTunnel has supported 9 types of Transforms including Common Options, Json, NullRate, Nulltf, Replace, Split, SQL, UDF, and UUID, and the community is welcome to contribute more Transform types.</p><p>For details of Transform, please refer to the official documentation: <a href="https://seatunnel.apache.org/docs/2.1.3/category/transform" target="_blank" rel="noopener noreferrer">https://seatunnel.apache.org/docs/2.1.3/category/transform</a></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="clickhousefile-connector-supports-rsync-data-transfer-method-now">ClickhouseFile connector supports Rsync data transfer method now<a class="hash-link" href="#clickhousefile-connector-supports-rsync-data-transfer-method-now" title="Direct link to heading">​</a></h3><p>At the same time, SeaTunnel 2.1.3 version brings Rsync data transfer mode support to ClickhouseFile connector, users can now choose SCP and Rsync data transfer modes. Thanks to Emor-nj for contributing to this feature.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="specific-feature-updates">Specific feature updates:<a class="hash-link" href="#specific-feature-updates" title="Direct link to heading">​</a></h3><ul><li>Flink Fake data supports BigInteger type <a href="https://github.com/apache/incubator-seatunnel/pull/2118" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2118</a></li><li>Add Flink Assert Sink connector <a href="https://github.com/apache/incubator-seatunnel/pull/2022" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2022</a></li><li>Spark ClickhouseFile connector supports Rsync data file transfer method <a href="https://github.com/apache/incubator-seatunnel/pull/2074" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2074</a></li><li>Add Flink Assert Sink e2e module <a href="https://github.com/apache/incubator-seatunnel/pull/2036" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2036</a></li><li>Add NullRate Transform for detecting data quality <a href="https://github.com/apache/incubator-seatunnel/pull/1978" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/1978</a></li><li>Add Nulltf Transform for setting defaults <a href="https://github.com/apache/incubator-seatunnel/pull/1958" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/1958</a></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="optimization">Optimization<a class="hash-link" href="#optimization" title="Direct link to heading">​</a></h3><ul><li>Refactored Spark TiDB-related parameter information</li><li>Refactor the code to remove redundant code warning information</li><li>Optimize connector jar package loading logic</li><li>Add Plugin Discovery module</li><li>Add documentation for some modules</li><li>Upgrade common-collection from version 4 to 4.4</li><li>Upgrade common-codec version to 1.13</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="bug-fix">Bug Fix<a class="hash-link" href="#bug-fix" title="Direct link to heading">​</a></h3><p>In addition, in response to the feedback from users of version 2.1.2, we also fixed some usability issues, such as the inability to use the same components of Source and Sink, and further improved the stability.</p><ul><li>Fixed the problem of Hudi Source loading twice</li><li>Fix the problem that the field TwoPhaseCommit is not recognized after Doris 0.15</li><li>Fixed abnormal data output when accessing Hive using Spark JDBC</li><li>Fix JDBC data loss when partition_column (partition mode) is set</li><li>Fix KafkaTableStream schema JSON parsing error</li><li>Fix Shell script getting APP_DIR path error</li><li>Updated Flink RunMode enumeration to get correct help messages for run modes</li><li>Fix the same source and sink registered connector cache error</li><li>Fix command line parameter -t( — check) conflict with Flink deployment target parameter</li><li>Fix Jackson type conversion error problem</li><li>Fix the problem of failure to run scripts in paths other than SeaTunnel_Home</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="acknowledgment">Acknowledgment<a class="hash-link" href="#acknowledgment" title="Direct link to heading">​</a></h3><p>Thanks to all the contributors (GitHub ID, in no particular order,), it is your efforts that fuel the launch of this version, and we look forward to more contributions to the Apache SeaTunnel(Incubating) community!</p><p><code>leo65535, CalvinKirs, mans2singh, ashulin, wanghuan2054, lhyundeadsoul, tobezhou33, Hisoka-X, ic4y, wsyhj, Emor-nj, gleiyu, smallhibiscus, Bingz2, kezhenxu94, youyangkou, immustard, Interest1-wyt, superzhang0929, gaaraG, runwenjun</code></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/Upcoming API Connector Development Analysis">Upcoming API Connector Development Analysis</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-06-23T00:00:00.000Z" itemprop="datePublished">June 23, 2022</time> · <!-- -->4 min read</div></header><div class="markdown" itemprop="articleBody"><p>After days of community development, the preliminary development of the new Connector API of SeaTunnel is completed. The next step is to adapt this new connector. In order to aid the developers to use this connector, this article provides guide to develop a new API.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="priliminary-setup">Priliminary Setup<a class="hash-link" href="#priliminary-setup" title="Direct link to heading">​</a></h2><ul><li><p>Environment configuration: JDK8 and Scala2.11 are recommended.</p></li><li><p>As before, we need to download the latest code locally through git and import it into the IDE, project address: <a href="https://github.com/apache/incubator-seatunnel" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel</a> . At the same time, switch the branch to api-draft, and currently use this branch to develop the new version of the API and the corresponding Connector. The project structure is as follows:</p><p><img loading="lazy" alt="Project Structure" src="/assets/images/0-82b23e9c80c8b70ce10feaccfc96a2a6.png" width="583" height="1014"></p></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="prerequisites">Prerequisites<a class="hash-link" href="#prerequisites" title="Direct link to heading">​</a></h2><ul><li><p>At present, in order to distinguish different Connectors, we put the connectors that support</p><ul><li>Flink/Spark under the <code>seatunnel-connectors/seatunnel-connectors-flink(spark)</code> module.</li><li>New version of the Connector is placed under the <code>seatunnel-connectors/seatunnel-connectors-seatunnel</code> module.</li></ul><p>As we can see from the above figure, we have implemented Fake, Console, Kafka Connector, and Clickhouse Connector is also being implemented.</p></li><li><p>At present, the data type we support is SeaTunnelRow, so no matter the type of data generated by the Source or the type of data consumed by the Sink, it should be SeaTunnelRow.</p></li></ul><h1>Development of Connector</h1><p>Taking Fake Connector as an example, let&#x27;s introduce how to implement a new Connector:</p><ul><li><p>Create a corresponding module with a path under <code>seatunnel-connectors-seatunnel</code>, which is at the same level as other new connectors.</p></li><li><p>Modify the <code>seatunnel-connectors-seatunnel/pom.xml</code> file, add a new module to modules, modify <code>seatunnel-connectors-seatunnel/seatunnel-connector-seatunnel-fake/pom.xml</code>, add seatunnel-api dependencies, and correct parent Quote. The resulting style is as follows:</p><p><img loading="lazy" alt="Style" src="/assets/images/1-27a269d360e9ee05b1dd696eeb0aa8e4.png" width="949" height="568"></p></li><li><p>The next step is to create the corresponding package and related classes, create FakeSource, and need to inherit SeaTunnel Source.</p><ul><li>Note : The Source of SeaTunnel adopts the design of stream and batch integration. The Source of SeaTunnel determines whether current Source is a stream or batch through attribute getBoundedness.</li></ul><p>So you can specify a Source as a stream or batch by dynamic configuration (refer to the default method). The configuration defined by the user in the configuration file can be obtained through the prepare method to realize the customized configuration.</p><p>Then create FakeSourceReader, FakeSource SplitEnumerator, and FakeSourceSplit to inherit the corresponding abstract classes (which can be found in the corresponding classes). As long as we implement the corresponding methods of these classes, then our SeaTunnel Source Connector is basically completed.</p></li><li><p>Next, just follow the existing example to write the corresponding code. The most important one is the FakeSource Reader, which defines how we obtain data from the outside, which is the most critical part of the Source Connector. Every time a piece of data is generated, we need to place it in the collector as shown:</p><p><img loading="lazy" alt="Source" src="/assets/images/2-6e56482ef5f497868040295fe7edff23.png" width="935" height="424"></p></li><li><p>After the code development is complete, we need to configure the configuration file <code>plugin-mapping.properties</code> located under <code>seatunnel-connectors/modules</code>. Adding a seatunnel
<code>.source.FakeSource = seatunnel-connector-fake</code>
means that SeaTunnel can find the jar package corresponding to the project by looking for a Source named FakeSource. This allows the Connector to be used in the normal configuration file.</p></li><li><p>For a detailed description of writing Source and Sink and SeaTunnel API, please refer to the introduction at <code>seatunnel-connectors/seatunnel-connectors-seatunnel/ README.zh.md</code>.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="connector-testing">Connector Testing<a class="hash-link" href="#connector-testing" title="Direct link to heading">​</a></h2><ul><li>For testing, we can find the <code>seatunnel-flink(spark)-new-connector-example</code> module in seatunnel-examples, and test it against different engines to ensure that the performance of the Connector is as consistent as possible. If you find any discrepancies, you can mark them in the document, modify the configuration file under resource, add our Connector to the configuration, and introduce <code>seatunnel-flink(spark)-new-connector-example/pom.xml</code> dependency, you can execute <code>SeaTunnelApiExample</code> to test.</li><li>The default is stream processing mode, and the execution mode is switched to batch mode by modifying <code>job.mode=BATCH</code> in the environment of the configuration file.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="submit-pr">Submit PR<a class="hash-link" href="#submit-pr" title="Direct link to heading">​</a></h2><p>When our Connector is ready, we can submit PR to github. After reviewing by other partners, our contributed Connector will become part of SeaTunnel!</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/How dose Apache SeaTunnel refactor the API to decouple with the computing engine">How dose Apache SeaTunnel refactor the API to decouple with the computing engine</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-05-31T00:00:00.000Z" itemprop="datePublished">May 31, 2022</time> · <!-- -->12 min read</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/assets/images/0-1b0b7ccac22c107239f10a37321c7719.jpg" width="1920" height="1316"></p><p>Translator | Critina</p><p>In the May joint Meetup between Apache SeaTunnel and Apache Inlong, Li Zongwen, a senior engineer at WhaleOps, shared his experiences about finding and refactoring of the the four major problems with Apache SeaTunnel (Incubating).i.e. the connectors of SeaTunnel have to be implemented many times,the inconsistent parameters, SeaTunnel is not supportive of multiple versions of the engine, and it’s difficult to upgrade the engine. In order to solve these problems, Li Zongwen aimed to decouple Apache SeaTunnel (Incubating) from thw computing engines, and re-factor the Source and Sink apis to improve the development experience.</p><p>This speech mainly consists of five parts.The first part is about Apache SeaTunnel (Incubator) refactoring background and motivation. The second part introduces Apache SeaTunnel (Incubating) Target for refactoring.The third part discusses Apache SeaTunnel (Incubating) overall design for refactoring. The last two parts is about Apache SeaTunnel (Incubating) Source API design and Apache SeaTunnel (Incubating) Sink API design.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="01-background-and-motivation-for-refactoring">01 Background and motivation for refactoring<a class="hash-link" href="#01-background-and-motivation-for-refactoring" title="Direct link to heading">​</a></h2><p>Those of you who have used Apache SeaTunnel (Incubator) or developers should know that Apache SeaTunnel (Incubator) is now fully coupled with the engine, which is entirely based on Spark or Flink, and so are the configuration file parameters. From the perspective of contributors and users, we can find they face some problems.</p><p>In the view of the contributors, repeated implementing connector is meaningless and it is unable for potential contributors to contribute to the community due to inconsistent engine versions.</p><p>At present, many companies use Lambda architecture, Spark is used for offline operations and Flink is used for real-time operations. In the view of the users, it can be found that Spark may have the Connector of SeaTunnel, but Flink does not, and the parameters of the two engines for the Connector of the same storage engine are not unified, thus resulting a high cost of and deviating from its original intention of being easy to use. And some users question that Flink version 1.14 is not supported nowadays. While with the current SeaTunnel architecture, we must discard the previous version in order to support Flink version 1.14, which will bring great trouble for early version users.</p><p>As a result, it was difficult for us to either upgrade engine or support more versions.</p><p>In addition, Spark and Flink both adopt the Checkpoint fault-tolerant mechanism implemented by Chandy-Lamport algorithm and internally unify DataSet and DataStream. On this premise, we believe decoupling is feasible.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="02-apache-seatunnel-incubating-decouples-with-computing-engine">02 Apache SeaTunnel (Incubating) decouples with computing engine<a class="hash-link" href="#02-apache-seatunnel-incubating-decouples-with-computing-engine" title="Direct link to heading">​</a></h2><p>Therefore, in order to solve the problems raised above, we set the following goals.</p><ol><li><p>Connector is only implemented once. To solve the problems that parameters are not unified and Connector is implemented for too many times, we hope to achieve a unified Source and Sink API;</p></li><li><p>Multiple versions of Spark and Flink engines are supported. A translation layer above the Source and Sink API is added to support multiple versions of Spark and Flink engines.</p></li><li><p>The logic for parallel shard of Source and the Sink submission should be clarified. We must provide a good API to support Connector development.</p></li><li><p>The full database synchronization in real-time scenarios should be supported. This is a derivative requirement that many users have mentioned for CDC support. I once participated the Flink CDC community before and many users pointed out that in the CDC scenario, if you wanted to use the Flink CDC directly, each table would have a link and there would be thousands of links for thousands of tables when you need to synchronize the whole library, which was unacceptable for both the database and the DBA. To solve this problem, the simplest way was to introduce Canal、Debezium or other components, which were used to pull incremental data to Kafka or other MQ for intermediate storage, and then we could use Flink SQL for synchronization. This actually contradicted the original idea of the Flink CDC to reduce links. However, the Flink CDC aimed only a Connector and was unable to deal with the whole link, so the proposal was not seen in the SeaTunnel community. By the chance of the reconstruction, we submitted the proposal to the SeaTunnel community.</p></li><li><p>Automatic discovery and storage of meta information are realized. The users should have awful experience due to the storage engines such as Kafka lacking of record of the data structure, when we need to read structured data, the user must define the topic of structured data types before read one topic at a time . We hope once the configuration is completed, there is no need to do any redundant work again.</p></li></ol><p>Some people may wonder why we don’t use Apache Beam directly. That is because Beam sources are divided into BOUNDED and UNBOUNDED sources, which means it needs to be implemented twice. Moreover, some features of Source and Sink are not supported, which will be mentioned later.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="03-apache-seatunnelincubating-overall-design-for-refactoring">03 Apache SeaTunnel(Incubating) overall design for refactoring<a class="hash-link" href="#03-apache-seatunnelincubating-overall-design-for-refactoring" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/1-cbc169e3bc121f1008b807103abe9fd8.jpg" width="1440" height="810"></p><p>The Apache SeaTunnel(Incubating) API architecture is described in the picture above.</p><p>The Source &amp; Sink API is one of the core APIS of data integration, which defines the logic for parallel shard of Source and the commitment of Sink to realize the Connector.</p><p>The Engine API includes the translation and the execution layers. The translation is used to translate Souce and Sink API of SeaTunnel into connectors that can be run inside the engine.</p><p>The execution defines the execution logic of Source, Transform, Sink and other operations in the engine.</p><p>The Table SPI is mainly used to expose the interface of Source and Sink in SPI mode, and to specify mandatory and optional parameters of Connector etc.</p><p>The DataType includes SeaTunnel data structure used to isolate engines and declare Table schema.</p><p>The Catalog is Used to obtain Table schemes and Options, etc. The Catalog Storage is used to store Table Schemes defined by unstructured engines such as Kafka.</p><p><img loading="lazy" src="/assets/images/2-507471aef3b2e7dc6ee4bc03188bc784.jpg" width="1440" height="810"></p><p>The execution flow we assumed nowadays can be see in the above picture.</p><ol><li><p>Obtain task parameters from configuration files or UI.</p></li><li><p>Obtain the Table Schema, Option and other information by analyzing the parameters from Catalog.</p></li><li><p>Pull up the Connector of SeaTunnel in SPI mode and inject Table information.</p></li><li><p>Translate the Connector from SeaTunnel into the Connector within the engine.</p></li><li><p>Execute the operation logic of the engine. The multi-table distribution in the picture only exists in the synchronization of the whole database of CDC, while other connectors are single tables and do not need the distribution logic.</p></li></ol><p>It can be seen that the hardest part of the plan is to translate Source and Sink into an internal Source and Sink in the engine.</p><p>Many users today use Apache SeaTunnel (Incubating) not only as a data integration tool but also as a data storage tool, and use a lot of Spark and Flink SQLs. We want to preserve that SQL capability for users to upgrade seamlessly.</p><p><img loading="lazy" src="/assets/images/3-68113e215aa8e91a5d2469ccb37a3c22.jpg" width="1440" height="810"></p><p>According to our research, the feature above shows the ideal execution logic of Source and Sink. Since SeaTunnel is incubated as WaterDrop, the terms in the figure are tended towards Spark.</p><p>Ideally, the Source and Sink coordinators can be run on the Driver, and the Source Reader and Sink Writer will run on the Worker. In terms of the Source Coordinator, we expect it to support several features.</p><p>The first capability is that the slicing logic of data can be dynamically added to the Reader.</p><p>The second is that the coordination of Reader can be supported. Source Reader is used to read data, and then send the data to the engine, and finally to the Source Writer for data writing. Meanwhile, Writer can support the two-phase transaction submission, and the coordinator of Sink supports the aggregation submission requirements of Connector such as Iceberg.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="04-source-api">04 Source API<a class="hash-link" href="#04-source-api" title="Direct link to heading">​</a></h2><p>After research, we found the following features that are required by Source.</p><ol><li><p>Unified offline and real-time API , which supports that source is implemented only once and supports both offline and real-time API;</p></li><li><p>Supportive of parallel reading. For example that Kafka generates a reader for each partition and execute in parallel.</p></li><li><p>Supporting dynamic slice-adding. For example, Kafka defines a regular topic, when a new topic needs to be added due to the volume of business, the Source API allows to dynamically add the slice to the job.</p></li><li><p>Supporting the work of coordinating reader, which is currently only needed in the CDC Connector. CDC is currently supported by NetFilx’s DBlog parallel algorithms, which requires reader coordination between full synchronization and incremental synchronization.</p></li><li><p>Supporting a single reader to process multiple tables, i.e. to allows the whole database synchronization in the real-time scenario as mentioned above.</p></li></ol><p><img loading="lazy" src="/assets/images/4-ac907e3f8e305b9f6585d2171013a973.jpg" width="1440" height="810"></p><p>Based on the above requirements, we have created the basic API as shown in the figure above. And the code has been submitted to the API-Draft branch in the Apache SeaTunnel(Incubator) community. If you’re interested, you can view the code in detail.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="how-to-adapt-to-spark-and-flink-engines">How to adapt to Spark and Flink engines<a class="hash-link" href="#how-to-adapt-to-spark-and-flink-engines" title="Direct link to heading">​</a></h3><p>Flink and Spark unify the API of DataSet and DataStream, and they can support the first two features. Then, for the remaining three features, how do we</p><ul><li>Support dynamic slice-adding？</li><li>Support the work of coordinating reader？</li><li>Support a single reader to process multiple tables？</li></ul><p>Let&#x27;s review the design with questions.</p><p><img loading="lazy" src="/assets/images/5-f743cf882b36bb3c383c66dec4bad95f.jpg" width="1440" height="810"></p><p>We found that other connectors do not need coordinators, except for CDC. For those connectors that do not need coordinators, we have a Source that supports parallel execution and engine translation.</p><p>As shown in the figure above, there is a slice enumerator on the left, which can list which slices the source needs and show what there are. After enumerating slices in real time, each slice would be distributed to SourceReader, the real data reading module. Boundedness marker is used to differentiate offline and real-time operations. Connector can mark whether there is a stop Offset in a slice. For example, Kafka can support real-time and offline operations. The degree of parallelism can be set for the ParallelSource in the engine to support parallel reading.</p><p>As shown in the figure above, in a scenario where a coordinator is required, Event transmission is done between the Reader and Enumerator. Enumerator coordinates events by the Event sent by the Reader. The Coordinated Source needs to ensure single parallelism at the engine level to ensure data consistency. Of course, this does not make good use of the engine’s memory management mechanism, but trade-offs are necessary.</p><p><img loading="lazy" src="/assets/images/6-ef5d53449db28f4466c14827335d07a6.jpg" width="1440" height="810"></p><p>For the last question, how can we support a single reader to process multiple tables? This involves the Table API layer. Once all the required tables have been read from the Catalog, some of the tables may belong to a single job and can be read by a link, and some may need to be separated, depending on how Source is implemented. Since this is a special requirement, we want to make it easier for the developers. In the Table API layer, we will provide a SupportMultipleTable interface to declare that Source supports multiple Table reads. The Source is implemented based on the corresponding deserializer of multiple tables. As for how to separate derived multi-table data, Flink will adopt Side Output mechanism, while Spark is going to use Filter or Partition mechanism.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="5-sink-api">5 Sink API<a class="hash-link" href="#5-sink-api" title="Direct link to heading">​</a></h2><p>At present, there are not many features required by Sink, but three mojor requirements are considerable according to our research.</p><p>The first is about idempotent writing, which requires no code and depends on whether the storage engine can support it.</p><p>The second is about distributed transactions. The mainstream method is two-phase commitments, such as Kafka etc.</p><p>The third is about the submission of aggregation. For Storage engines like Iceberg and Hoodie, we hope there is no issues triggered by small files, so we expect to aggregate these files into a single file and commit it as a whole.</p><p>Based on these three requirements, we built three APIS: SinkWriter, SinkCommitter, and SinkAggregated Committer. SinkWriter plays a role of writing, which may or may not be idempotent. SinkCommitter supports for two-phase commitments. SinkAggregatedCommitter supports for aggregated commitments.</p><p><img loading="lazy" src="/assets/images/7-e9830d63f81f7139a7cd1d4d9b9f5e43.jpg" width="1440" height="810"></p><p>Ideally, AggregatedCommitter runs in Driver in single or parallel, and Writer and Committer run in Worker with multiple parallels, with each parallel carrying its own pre-commit work and then send Aggregated messages to Aggregated committers.</p><p>Current advanced versions of Spark and Flink all support AggregatedCommitter running on the Driver(Job Manager) and Writer and Committer running on the worker(Task Manager).</p><p><img loading="lazy" src="/assets/images/8-aa0537c76d15543b46623445ff00e490.jpg" width="1440" height="810"></p><p>However, for the lower versions of Flink, AggregatedCommitter cannot be supported to run in JM, so we are also carrying translation adaptation. Writer and Committer will act as pre-operators, packaged by Flink’s ProcessFunction, supports concurrent pre-delivery and write, and implement two-phase commitment based on Flink’s Checkpoint mechanism. This is also the current 2PC implementation of many of Flink connectors. The ProcessFunction can send messages about pre-commits to downstream Aggregated committers, which can be wrapped around operators such as SinkFunction or ProcessFunction. Of course, We need to ensure that only one single parallel will be started by the AggregatedCommitter in case of the broken of the logic of the aggregated commitment.</p><p>Thank you for watching. If you’re interested in the specific implementations mentioned in my speech, you can refer to the Apache SeaTunnel (Incubating) community and check out the API-Draft branch code. Thank you again.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/blog/How to synchronize tens of billions of data based on SeaTunnel&#x27;s ClickHouse">How to synchronize tens of billions of data based on SeaTunnel&#x27;s ClickHouse</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-05-10T00:00:00.000Z" itemprop="datePublished">May 10, 2022</time> · <!-- -->8 min read</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/assets/images/0-c3f068094d4f0308d7100502a6162925.jpg" width="1920" height="1275"></p><p>Author | Fan Jia, Apache SeaTunnel(Incubating) Contributor
Editor | Test Engineer Feng Xiulan</p><p>For importing billions of batches of data, the traditional JDBC approach does not perform as well as it should in some massive data synchronization scenarios. To write data faster, Apache SeaTunnel (Incubating) has just released version 2.1.1 to provide support for ClickhouseFile-Connector to implement Bulk load data writing.</p><p>Bulk load means synchronizing large amounts of data to the target DB. SeaTunnel currently supports data synchronization to ClickHouse.</p><p>At the Apache SeaTunnel (Incubating) April Meetup, Apache SeaTunnel (Incubating) contributor Fan Jia shared the topic of &quot;ClickHouse bulk load implementation based on SeaTunnel&quot;, explaining in detail the implementation principle and process of ClickHouseFile for efficient processing of large amounts of data.</p><p>Thanks to the test engineer Feng Xiulan for the article arrangement!</p><p>This presentation contains seven parts.</p><ul><li>State of ClickHouse Sink</li><li>Scenarios that ClickHouse Sink isn&#x27;t good at </li><li>Introduction to the ClickHouseFile plugin</li><li>ClickHouseFile core technologies</li><li>Analysis of ClickHouseFile plugin implementation</li><li>Comparison of plug-in capabilities</li><li>Post-optimization directions</li></ul><p><img loading="lazy" src="/assets/images/0-1-56defefcc273a6e21b09dd483bf95914.png" width="1171" height="1171"></p><p>Fan Jia,  Apache SeaTunnel (Incubating) contributor, Senior Enginee of WhaleOps.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="01-status-of-clickhouse-sink">01 Status of ClickHouse Sink<a class="hash-link" href="#01-status-of-clickhouse-sink" title="Direct link to heading">​</a></h2><p>At present, the process of synchronizing data from SeaTunnel to ClickHouse is as follows: as long as the data source is supported by SeaTunnel, the data can be extracted, converted (or not), and written directly to the ClickHouse sink connector, and then written to the ClickHouse server via JDBC. </p><p><img loading="lazy" src="/assets/images/1-76284c6612152506e0111e0f0d25d0f5.png" width="1139" height="585"></p><p>However, there are some problems with writing to the ClickHouse server via traditional JDBC.</p><p>Firstly, the tool used now is the driver provided by ClickHouse and implemented via HTTP, however, HTTP is not very efficient to implement in certain scenarios. The second is the huge amount of data, if there is duplicate data or a large amount of data written at once, it needs to generate the corresponding insert statement and send it via HTTP to the ClickHouse server-side by the traditional method, where it is parsed and executed item by item or in batches, which does not allow data compression.</p><p>Finally, there is the problem we often encounter, i.e. too much data may lead to an OOM on the SeaTunnel side or a server-side hang due to too much data being written to the server-side too often.</p><p>So we thought, is there a faster way to send than HTTP? If data pre-processing or data compression could be done on the SeaTunnel side, then the network bandwidth pressure would be reduced and the transmission rate would be increased.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="02-scenarios-that-clickhouse-sink-isnt-good-at">02 Scenarios that ClickHouse Sink isn&#x27;t good at<a class="hash-link" href="#02-scenarios-that-clickhouse-sink-isnt-good-at" title="Direct link to heading">​</a></h2><ol><li>If the HTTP transfer protocol is used, HTTP may not be able to handle it when the volume of data is too large and the batch is sending requests in micro-batches.</li><li>Too many INSERT requests may put too much pressure on the server. The bandwidth can handle a large number of requests, but the server-side is not always able to carry them. The online server not only needs data inserts but more importantly, the query data can be used by other business teams. If the server cluster goes down due to too much-inserted data, it is more than worth the cost.</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="03-clickhouse-file-core-technologies">03 ClickHouse File core technologies<a class="hash-link" href="#03-clickhouse-file-core-technologies" title="Direct link to heading">​</a></h2><p>In response to these scenarios that ClickHouse is not good at, we wondered is there a way to do data compression right on the Spark side, without increasing the resource load on the Server when writing data, and with the ability to write large amounts of data quickly? So we developed the ClickHouseFile plugin to solve the problem.</p><p>The key technology of the ClickHouseFile plugin is ClickHouse -local. ClickHouse-local mode allows users to perform fast processing of local files without having to deploy and configure a ClickHouse Server. C lickHouse-local uses the same core as ClickHouse Server, so it supports most features as well as the same format and table engine.</p><p>These two features mean that users can work directly with local files without having to do the processing on the ClickHouse Server side. Because it is the same format, the data generated by the operations we perform on the remote or SeaTunnel side is seamlessly compatible with the server-side and can be written to using ClickHouse local. ClickHouse local is the core technology for the implementation of ClickHouseFile, which allows for implementing the ClickHouse file connector.</p><p>ClickHouse local core is used in the following ways.</p><p><img loading="lazy" src="/assets/images/2-2367f70ae655c30a94a2ec65e67a6b26.png" width="1112" height="262"></p><p>First line: pass the data to the test_table table of the ClickHouse-local program via the Linux pipeline.</p><p>Lines two to five: create a result_table for receiving data.</p><p>The sixth line: pass data from test_table to the result_table.</p><p>Line 7: Define the disk path for data processing.</p><p>By calling the Clickhouse-local component, the Apache SeaTunnel (Incubating) is used to generate the data files and compress the data. By communicating with the Server, the generated data is sent directly to the different nodes of Clickhouse and the data files are then made available to the nodes for the query.</p><p>Comparison of the original and current implementations.</p><p><img loading="lazy" src="/assets/images/3-6204c709b48243f88914bfd492dc67f2.png" width="1272" height="576"></p><p>Originally, the data, including the insert statements was sent by Spark to the server, and the server did the SQL parsing, generated and compressed the table data files, generated the corresponding files, and created the corresponding indexes. If we use ClickHouse local technology, the data file generation, file compression and index creation are done by SeaTunnel, and the final output is a file or folder for the server-side, which is synchronized to the server and the server can queries the data without additional operations.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="04-core-technical-points">04 Core technical points<a class="hash-link" href="#04-core-technical-points" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/4-d47e1da865afa7ea4de50b2d6e4b6ac1.png" width="1164" height="435"></p><p>The above process makes data synchronization more efficient, thanks to three optimizations we have made to it.</p><p>Firstly, the data is transferred from the pipeline to the ClickHouseFile by the division, which imposes limitations in terms of length and memory. For this reason, we write the data received by the ClickHouse connector, i.e. the sink side, to a temporary file via MMAP technology, and then the ClickHouse local reads the data from the temporary file to generate our target local file, in order to achieve the effect of incremental data reading and solve the OM problem.</p><p><img loading="lazy" src="/assets/images/5-9f00635b1727843f705cd5a28632e2e4.png" width="1206" height="565"></p><p>Secondly, it supports sharding. If only one file or folder is generated in a cluster, the file is distributed to only one node, which will greatly reduce the performance of the query. Therefore, we carry out slicing support. Users can set the key for slicing in the configuration folder, and the algorithm will divide the data into multiple log files and write them to different cluster nodes, significantly improving the read performance.</p><p><img loading="lazy" src="/assets/images/6-35b30550d6a18fbea49856083aa85094.png" width="1043" height="558"></p><p>The third key optimization is file transfer. Currently, SeaTunnel supports two file transfer methods, one is SCP, which is characterized by security, versatility, and no additional configuration; the other is RSYNC, which is somewhat fast and efficient and supports breakpoint resume, but requires additional configuration, users can choose between the way suits their needs.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="05-plugin-implementation-analysis">05 Plugin implementation analysis<a class="hash-link" href="#05-plugin-implementation-analysis" title="Direct link to heading">​</a></h2><p>In summary, the general implementation process of ClickHouseFile is as follows.</p><p><img loading="lazy" src="/assets/images/7-1be978da30a55fe0289c683f2ae61aac.png" width="533" height="635"></p><p>1.caching data to the ClickHouse sink side.
2.calling ClickHouse-local to generate the file.
3.sending the data to the ClickHouse server.
4.Execution of the ATTACH command.</p><p>With the above four steps, the generated data reaches a queryable state.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="06-comparison-of-plug-in-capabilities">06 Comparison of plug-in capabilities<a class="hash-link" href="#06-comparison-of-plug-in-capabilities" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/8-261e7ba686f3fadf5d7c1445e9be5b66.png" width="1071" height="485"></p><p>(a) In terms of data transfer, ClickHouseFile is more suitable for massive amounts of data, with the advantage that no additional configuration is required and it is highly versatile, while ClickHouseFile is more complex to configure and currently supports fewer engines.</p><p>In terms of environmental complexity, ClickHouse is more suitable for complex environments and can be run directly without additional configuration.</p><p>In terms of versatility, ClickHouse, due to being an officially supported JDBC diver by SeaTunnel, basically supports all engines for data writing, while ClickHouseFile supports relatively few engines.</p><p>In terms of server pressure, ClickHouseFile&#x27;s advantage shows when it comes to massive data transfers that don&#x27;t put too much pressure on the server.</p><p>However, the two are not in competition and the choice needs to be based on the usage scenario.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="07-follow-up-plans">07 Follow-up plans<a class="hash-link" href="#07-follow-up-plans" title="Direct link to heading">​</a></h2><p>Although SeaTunnel currently supports the ClickHouseFile plugin, there are still many defects that need to be optimized, mainly including</p><ul><li>Rsync support.</li><li>Exactly-Once support.</li><li>Zero Copy support for transferring data files.</li><li>More Engine support.</li></ul><p>Anyone interested in the above issues is welcome to contribute to the follow-up plans, or tell me your ideas!</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/page/2"><div class="pagination-nav__label">Older Entries</div></a></div></nav></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">SeaTunnel</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/faq">FAQ</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel/releases" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Releases<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Issue Tracker<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel/pulls" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Pull Requests<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Subscribe Mailing List</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/community/contribution_guide/subscribe">How to Subscribe</a></li><li class="footer__item"><a href="mailto:dev-subscribe@seatunnel.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Subscribe Mail<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://lists.apache.org/list.html?dev@seatunnel.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Mail Archive<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">
            <div style="margin-top: 20px;background: #f4f8fa">
                <img style="height:50px;margin-bottom: 10px" alt="Apache Software Foundation" src="/image/incubator-logo.svg">
                <p style="color: #999999;font-weight:400;text-align:left">Apache SeaTunnel is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p>
                <div style="border-top: 1px solid #ccc;min-height: 60px;line-height: 20px;text-align: center;font-family: Avenir-Medium;font-size: 14px;color: #999;display: flex;align-items: center;"><span>Copyright © 2021-2023 The Apache Software Foundation. Apache SeaTunnel, SeaTunnel, and its feather logo are trademarks of The Apache Software Foundation.</span></div>
                <div style="text-align: center;">
                    <a href="https://twitter.com/asfseatunnel?s=21" target="_blank" title="Twitter"><svg t="1644553365083" class="icon" viewBox="0 0 1260 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7015" width="38" height="38"><path d="M1259.846921 121.148242c-46.524504 20.728739-96.273478 34.547899-148.325646 40.536201 53.434084-31.784067 94.430924-82.454319 113.777747-142.797982-50.209613 29.480874-105.486251 51.13089-164.447999 62.646857A257.584528 257.584528 0 0 0 872.449815 0.000276c-142.797982 0-258.418284 115.620302-258.418284 258.418284 0 20.268101 2.303193 40.075563 6.909579 58.961748C405.82286 306.32498 215.579097 203.602561 87.98219 47.446058c-22.110655 38.233008-35.008538 82.454319-35.008538 129.900099 0 89.824537 45.603227 168.593747 115.159663 215.118251-42.378756-1.381916-81.99368-12.897882-117.002217-32.244706v3.224471c0 125.293713 88.90326 229.398049 207.287393 253.351259-21.650017 5.988302-44.681949 9.212773-68.17452 9.212773-16.582991 0-32.705344-1.842555-48.827697-4.606387 32.705344 102.722419 128.518184 177.345881 241.374653 179.649074-88.442621 69.095798-199.917175 110.553277-321.06514 110.553277-20.728739 0-41.457479-1.381916-61.72558-3.685109 114.238386 73.241546 250.126788 116.08094 396.149241 116.08094 475.379089 0 735.179289-393.846048 735.179289-735.179289 0-11.055328-0.460639-22.571294-0.921277-33.626621 51.13089-36.851092 94.891562-82.454319 129.439461-134.045848z" fill="#909094" p-id="7016"></path></svg></a> 
                    <a href="https://join.slack.com/t/apacheseatunnel/shared_invite/zt-123jmewxe-RjB_DW3M3gV~xL91pZ0oVQ" target="_blank" title="Slack" style="margin-left: 20px;"><svg t="1644553076784" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3088" width="36" height="36"><path d="M215.125333 647.04a107.861333 107.861333 0 0 1-107.52 107.648A107.861333 107.861333 0 0 1 0 647.04a107.818667 107.818667 0 0 1 107.605333-107.52h107.52v107.52z m54.229334 0a107.818667 107.818667 0 0 1 107.562666-107.52 107.818667 107.818667 0 0 1 107.562667 107.52v269.354667A107.861333 107.861333 0 0 1 376.917333 1024a107.861333 107.861333 0 0 1-107.562666-107.605333v-269.354667zM376.917333 215.125333a107.861333 107.861333 0 0 1-107.562666-107.52A107.861333 107.861333 0 0 1 376.917333 0a107.861333 107.861333 0 0 1 107.562667 107.605333v107.52H376.917333z m0 54.229334a107.861333 107.861333 0 0 1 107.562667 107.562666 107.861333 107.861333 0 0 1-107.562667 107.562667H107.605333A107.861333 107.861333 0 0 1 0 376.917333a107.861333 107.861333 0 0 1 107.605333-107.562666h269.312z m431.872 107.562666a107.861333 107.861333 0 0 1 107.605334-107.562666A107.861333 107.861333 0 0 1 1024 376.917333a107.861333 107.861333 0 0 1-107.605333 107.562667h-107.605334V376.917333z m-54.101333 0a107.861333 107.861333 0 0 1-107.648 107.562667 107.818667 107.818667 0 0 1-107.52-107.562667V107.605333A107.818667 107.818667 0 0 1 647.04 0a107.861333 107.861333 0 0 1 107.648 107.605333v269.312z m-107.648 431.872a107.861333 107.861333 0 0 1 107.648 107.605334A107.861333 107.861333 0 0 1 647.04 1024a107.818667 107.818667 0 0 1-107.52-107.605333v-107.605334h107.52z m0-54.101333a107.818667 107.818667 0 0 1-107.52-107.648 107.776 107.776 0 0 1 107.52-107.52h269.354667A107.818667 107.818667 0 0 1 1024 647.04a107.861333 107.861333 0 0 1-107.605333 107.648h-269.354667z" p-id="3089" fill="#909094"></path></svg></a> 
                    <a href="https://lists.apache.org/list.html?dev@seatunnel.apache.org" target="_blank" title="Mailing list" style="margin-left: 20px;"><svg t="1644553175467" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5304" width="39" height="39"><path d="M853.333333 170.666667H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333333v512c0 46.933333 38.4 85.333333 85.333334 85.333333h682.666666c46.933333 0 85.333333-38.4 85.333334-85.333333V256c0-46.933333-38.4-85.333333-85.333334-85.333333z m0 170.666666l-341.333333 213.333334-341.333333-213.333334V256l341.333333 213.333333 341.333333-213.333333v85.333333z" p-id="5305" fill="#909094"></path></svg></a> 
                    <a href="https://github.com/apache/incubator-seatunnel" target="_blank" title="GitHub" style="margin-left: 20px;"><svg t="1644553223000" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6156" width="36" height="36"><path d="M512 12.64c-282.752 0-512 229.216-512 512 0 226.208 146.72 418.144 350.144 485.824 25.6 4.736 35.008-11.104 35.008-24.64 0-12.192-0.48-52.544-0.704-95.328-142.464 30.976-172.512-60.416-172.512-60.416-23.296-59.168-56.832-74.912-56.832-74.912-46.464-31.776 3.52-31.136 3.52-31.136 51.392 3.616 78.464 52.768 78.464 52.768 45.664 78.272 119.776 55.648 148.992 42.56 4.576-33.088 17.856-55.68 32.512-68.48-113.728-12.928-233.28-56.864-233.28-253.024 0-55.904 20-101.568 52.768-137.44-5.312-12.896-22.848-64.96 4.96-135.488 0 0 43.008-13.76 140.832 52.48a491.296 491.296 0 0 1 128.16-17.248c43.488 0.192 87.328 5.888 128.256 17.248 97.728-66.24 140.64-52.48 140.64-52.48 27.872 70.528 10.336 122.592 5.024 135.488 32.832 35.84 52.704 81.536 52.704 137.44 0 196.64-119.776 239.936-233.792 252.64 18.368 15.904 34.72 47.04 34.72 94.816 0 68.512-0.608 123.648-0.608 140.512 0 13.632 9.216 29.6 35.168 24.576C877.472 942.624 1024 750.784 1024 524.64c0-282.784-229.248-512-512-512z" p-id="6157" fill="#909094"></path></svg></a> 
                </div>
            <div></div></div></div></div></div></footer></div>
<script src="/assets/js/runtime~main.8e37f3a6.js"></script>
<script src="/assets/js/main.80d5c78f.js"></script>
</body>
</html>